/* Generated by re2c 1.3 on Wed Jul  1 11:33:14 2020 */
#line 1 "lexer.re"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "lexer.h"
#include "parser.h"
#include "error.h"


Scanner* createScanner(FILE* in)
{
    Scanner* scnr = (Scanner*)malloc(sizeof(Scanner));
    memset (scnr->buf, 0, SCANNER_BUF_SZ + 1);
    scnr->yych = 0;
    scnr->end = scnr->cursor = scnr->token = scnr->marker = scnr->buf + SCANNER_BUF_SZ;
    scnr->yyaccept = 0;
    scnr->state = -1;
    if (in) {
      if (in == stdin)
        scnr->is_stdin = true;
      else
        scnr->is_stdin = false;

      scnr->yyin = in;
    }
    else {
      scnr->yyin = stdin;
      scnr->is_stdin = true;
    }
    return scnr;
}

void destroyScanner(Scanner* scanner)
{
  free(scanner);
}

void yysetbuffer(Scanner* scnr, char* text, int len)
{
    if (len > SCANNER_BUF_SZ)
        error_abort("cannot buffer input text, aborting", __FILE__, __LINE__);

    memset (scnr->buf, 0, SCANNER_BUF_SZ);
    memcpy (scnr->buf, text, len);

    scnr->cursor = scnr->marker = scnr->mrkctx = scnr->token = scnr->buf;
    /*
        I removed a (+ 1) from the end of this line,
        thinking that it may solve the issue where the
        lexer inserts the ERR token when lexing the
        NEWLINE at the end of the buffer (filled with
        text from the user via getline.)
    */
    scnr->end = scnr->buf + len;
}

int yyfill(Scanner* scanner)
{
  /*
    technically the new scanner never calls YYFILL by definition,
    so this function is always useless. but it is necessary if
    we ever want to write a stream frontend for the compiler.
    this function will be used to request more tokens from the
    user of an interpreter, or if the compiler needs more input
    from a file being compiled. but all of that will need to be
    decided later, for the various frontends. given that the
    extensions mentioned above are in fact usefull, we will leave
    this function alone until we need it.

    buf->[c0, c1, c2, .., ctoken-1, ctoken, .., cend-1, cend, .., cbuf+SCANNER_BUF_SZ]

    ->token points to the character just past the last token processed.
    (in other words, at the beginning of the next token to process.)
    the difference between the start of the array (->buf) and
    the end of the last token (->token) is the space currently
    being occupied by processed characters in the array.
    (it is the 'processed' text.)

    available is the slots in the buffer left which can be filled
    with more characters. it is the total slots in the array available
    minus the slots taken up by the unprocessed slots sitting
    between the end of the last token (->token) and the end of
    the buffered input (->end) (the 'unprocessed' characters as it were)

    so the goal of this function is to shift the unprocessed
    input left in the buffer to the bottom of the array, and
    fill the now available space with more input from the input FILE.
  */
  size_t charsRead = 0;
  size_t processed = scanner->token - scanner->buf;
  size_t available = SCANNER_BUF_SZ - (scanner->end - scanner->token);

  if (available < 1) return -1;

  memmove(scanner->buf, scanner->token, SCANNER_BUF_SZ - processed);
  scanner->end    -= processed;
  scanner->cursor -= processed;
  scanner->token  -= processed;

  if (scanner->is_stdin)
    printf(":> ");
  charsRead = getline(&(scanner->end), &available, scanner->yyin);

  if (charsRead < 0) {
    /*
    getline returns -1 after errors and eof;
    so distinguish between real errors and
    the known case of end of input.
     */
    if (!feof(scanner->yyin)) {
      perror("yylex:getline");
      exit(1);
    }
  }
  else {
    scanner->end += charsRead;
    scanner->end[0] = 0;
  }

  return charsRead;
}

char* yytext(Scanner* scanner)
{
    return strndup(scanner->token, scanner->cursor - scanner->token);
}

StrLoc* yylloc(Scanner* scanner)
{
    return (StrLoc*)(&(scanner->yylloc));
}


void update_location(StrLoc* llocp, char* token, int length)
{
    llocp->first_line   = llocp->last_line;
    llocp->first_column = llocp->last_column;

    for (int i = 0; i < length; i++) {
        if (token[i] == '\n') {
            llocp->last_line++;
            llocp->last_column = 1;
        }
        else {
            llocp->last_column++;
        }
    }
}



/*
typedef struct Scanner {
	char  buf[SCANNER_BUF_SZ + 1];
    char* end;
    char* cursor;
	char* marker;
    char* token;
	unsigned int yyaccept;
	int state;
	FILE* yyin;
	char  yych;
	bool  is_stdin;
	struct {
		int first_line;
		int first_column;
		int last_line;
		int last_column;
	} yylloc;
} Scanner;

    needs of re2c:

    yych holds current input character.
    YYCTYPE is the type of yych

    YYCURSOR is of type YYCTYPE*, and is used to search for matches

    YYLIMIT is of type YYCTYPE*, and is used to delimit the end of the buffer.

    YYMARKER is of type YYCTYPE* and is used to backup the cursor after a successful
                match, in certain circumstances.


from the re2c manual
the default scanner behavior in terms of the generic interface.
these are the basic scanner primitives which drive the algorithm:
#define  YYPEEK ()         *YYCURSOR
#define  YYSKIP ()         ++YYCURSOR
#define  YYBACKUP ()       YYMARKER = YYCURSOR
#define  YYRESTORE ()      YYCURSOR = YYMARKER
this is the check for the end of the input:
#define  YYLESSTHAN (n)    YYLIMIT - YYCURSOR < n
these primitives are only used to support specific scanner features
in re2c, specifically, s-tags and m-tags, which from the docs are
used to implement "staDFA delayed store actions". which I do not know
what that is, but I am not using them so eh.
the context (CTX) primitives are used to support the specific
regular expression R \ S which is an R followed by an S but the S
is not consumed. (which is why it takes another pointer to support.)
(notice how the scanner data structure doesn't even define this context
 ptr, because it doesn't need to.)
#define  YYBACKUPCTX ()    YYCTXMARKER = YYCURSOR
#define  YYRESTORECTX ()   YYCURSOR = YYCTXMARKER
#define  YYRESTORERAG (t)  YYCURSOR = t
#define  YYSTAGP (t)       t = YYCURSOR
#define  YYSTAGPD (t)      t = YYCURSOR - 1
#define  YYSTAGN (t)       t = NULL
*/


#line 219 "lexer.re"


/*
    we want to support reading from an input source
    that may not give us all of the input in a single go.
    because that makes extending the compiler to handle
    very large files, multiple input sources, and reading
    input from an unreliable source like a socket, possible.
    (making the parser with this semantics from the beginning
    should work to say the interpreter semantics neatly,
    (as the user may enter half an expression on one call to
    getline and the other half on the second call.)
    and allow extension to be easier. simply because there will
    be less to change to fit with the extensions (each a situation
    in which the full input doesn't fit in the memory buffer
    foor parsing.).)

    we could tie the scanner and lexer together if we imagine the existance
    of the ';' symbol with the meaning of [term ';' term] in the grammar.

    this gives us an explicit lexical symbol with the meaning 'end-of-term'.

    we then allow empty expressions; by allowing an ending
    token to appear immediately as a primary
    leading to said empty expression. we could
    have a user insert a semicolon to 'end' an expression in
    the language. and silently we would parse this as
    (user input) ';' empty

    we could also parse an empty buffer as an empty term.
    and that can stop the parse.

    but we need to be very careful. I don't want every
    lone term to parse forever.

    - enter nothing, parser returns an empty term
        - typechecker types it as nothing,
        - evaluator evaluates it to nothing,
    - enter something valid, keep trying to
        fill the buffer until we reach an end token.

    to recap:
    terms like "(\x=>x)" will cause the parser to return for
    more input unless ended with a ';' token. (essentially
    the parser greedily wants to assume you are going to
    postfix an application or binop after a valid term,
    as that is it's required behavior when parsing some long
    expression, we as programmers want to have as much
    control over what get's parsed as possible, so the explicit
    'period' character (homomorphically (what i would call metaphorically
    if it were between two entities in reality being described by language.))
     ";" makes the most sense.)
    and "" will cause the parser to end immediately.
    this allows a user to enter a single full term by
    ending it with a ';'. (and if they enter nothing
    the parser will end, and the program will execute
    default no-op behavior. which is also technically what it
    does when evaluating the rhs of the semicolon.)
    we won't immediately try and construct any node, as the
    yyfill call is implicitly associated with reaching the end
    of input from the lexer. whereby it returns MORE.
    i think this means that the trigger for yymore needs to
    be lifted out of the scanner by way of making it reentrant,
    and the parser needs to call yyfill itself when it encounters
    the MORE token.
    then we need to care about a yymore that doesn't get any more,
    and wether that situation is an error or not.
    which depends on where we are in a parse. (im not sure what
    exactly to base this boolean judgement on. some flag allocated
    for this purpose? some particular arrangement of the already
    allocated memory?)
*/

#define YYPEEK()       *scanner->cursor
#define YYSKIP()       ++(scanner->cursor)
#define YYBACKUP()     scanner->marker = scanner->cursor
#define YYRESTORE()    scanner->cursor = scanner->marker
#define YYBACKUPCTX()  scanner->mrkctx = scanner->cursor
#define YYRESTORECTX() scanner->cursor = scanner->mrkctx
#define YYLESSTHAN(n)  (scanner->end - scanner->cursor) < n

int yylex(Parser* parser, Scanner* scanner)
{
loop:
  scanner->token = scanner->cursor;
  
#line 304 "lexer.c"
{
	char yych;
	yych = YYPEEK ();
	switch (yych) {
	case '\t':
	case ' ':	goto yy4;
	case '\n':	goto yy6;
	case '%':	goto yy8;
	case '(':	goto yy10;
	case ')':	goto yy12;
	case '*':	goto yy14;
	case '+':	goto yy16;
	case '-':	goto yy18;
	case '/':	goto yy20;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	case ':':	goto yy25;
	case ';':	goto yy27;
	case '=':	goto yy29;
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	case 'I':	goto yy33;
	case 'N':	goto yy34;
	case '\\':	goto yy35;
	case 'n':	goto yy37;
	case '{':	goto yy38;
	case '}':	goto yy40;
	default:
		if (YYLESSTHAN (1)) {
			goto yyeof;
		}
		goto yy2;
	}
yy2:
	YYSKIP ();
yy3:
#line 310 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ERR; }
#line 398 "lexer.c"
yy4:
	YYSKIP ();
#line 312 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); goto loop; }
#line 403 "lexer.c"
yy6:
	YYSKIP ();
#line 313 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NEWLN; }
#line 408 "lexer.c"
yy8:
	YYSKIP ();
#line 327 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 413 "lexer.c"
yy10:
	YYSKIP ();
#line 329 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LPAREN; }
#line 418 "lexer.c"
yy12:
	YYSKIP ();
#line 330 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RPAREN; }
#line 423 "lexer.c"
yy14:
	YYSKIP ();
#line 325 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 428 "lexer.c"
yy16:
	YYSKIP ();
#line 323 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 433 "lexer.c"
yy18:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy42;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy19;
	}
yy19:
#line 324 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 447 "lexer.c"
yy20:
	YYSKIP ();
#line 326 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 452 "lexer.c"
yy22:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy24;
	}
yy24:
#line 316 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT; }
#line 475 "lexer.c"
yy25:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '=':	goto yy44;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy26;
	}
yy26:
#line 318 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLON; }
#line 489 "lexer.c"
yy27:
	YYSKIP ();
#line 328 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return SEMICOLON; }
#line 494 "lexer.c"
yy29:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy46;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy3;
	}
yy30:
	YYSKIP ();
	yych = YYPEEK ();
yy31:
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	}
yy32:
#line 333 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ID; }
#line 581 "lexer.c"
yy33:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'n':	goto yy48;
	default:	goto yy31;
	}
yy34:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'i':	goto yy49;
	default:	goto yy31;
	}
yy35:
	YYSKIP ();
#line 320 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BSLASH; }
#line 608 "lexer.c"
yy37:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'i':	goto yy50;
	default:	goto yy31;
	}
yy38:
	YYSKIP ();
#line 331 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LBRACE; }
#line 624 "lexer.c"
yy40:
	YYSKIP ();
#line 332 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RBRACE; }
#line 629 "lexer.c"
yy42:
	YYSKIP ();
#line 322 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 634 "lexer.c"
yy44:
	YYSKIP ();
#line 319 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLONEQUALS; }
#line 639 "lexer.c"
yy46:
	YYSKIP ();
#line 321 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return REQARROW; }
#line 644 "lexer.c"
yy48:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 't':	goto yy51;
	default:	goto yy31;
	}
yy49:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy53;
	default:	goto yy31;
	}
yy50:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy55;
	default:	goto yy31;
	}
yy51:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy52;
	}
yy52:
#line 317 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT_TYPE; }
#line 753 "lexer.c"
yy53:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy54;
	}
yy54:
#line 315 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL_TYPE; }
#line 829 "lexer.c"
yy55:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy56;
	}
yy56:
#line 314 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL; }
#line 905 "lexer.c"
yyeof:
#line 311 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return END; }
#line 909 "lexer.c"
}
#line 334 "lexer.re"

}








































/* ---------------------------------------------------------------- */
