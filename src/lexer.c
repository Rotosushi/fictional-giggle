/* Generated by re2c 1.3 on Wed Jul  1 16:26:55 2020 */
#line 1 "lexer.re"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "lexer.h"
#include "parser.h"
#include "error.h"


Scanner* createScanner(FILE* in)
{
    Scanner* scnr = (Scanner*)malloc(sizeof(Scanner));
    memset (scnr->buf, 0, SCANNER_BUF_SZ + 1);
    scnr->yych = 0;
    scnr->end = scnr->cursor = scnr->token = scnr->marker = scnr->buf + SCANNER_BUF_SZ;
    scnr->yyaccept = 0;
    scnr->state = -1;
    if (in) {
      if (in == stdin)
        scnr->is_stdin = true;
      else
        scnr->is_stdin = false;

      scnr->yyin = in;
    }
    else {
      scnr->yyin = stdin;
      scnr->is_stdin = true;
    }
    return scnr;
}

void destroyScanner(Scanner* scanner)
{
  free(scanner);
}

void yysetbuffer(Scanner* scnr, char* text, int len)
{
    if (len > SCANNER_BUF_SZ)
        error_abort("cannot buffer input text, aborting", __FILE__, __LINE__);

    memset (scnr->buf, 0, SCANNER_BUF_SZ);
    memcpy (scnr->buf, text, len);

    scnr->cursor = scnr->marker = scnr->mrkctx = scnr->token = scnr->buf;
    /*
        I removed a (+ 1) from the end of this line,
        thinking that it may solve the issue where the
        lexer inserts the ERR token when lexing the
        NEWLINE at the end of the buffer (filled with
        text from the user via getline.)
    */
    scnr->end = scnr->buf + len;
}

int yyfill(Scanner* scanner)
{
  /*
    technically the new scanner never calls YYFILL by definition,
    so this function is always useless. but it is necessary if
    we ever want to write a stream frontend for the compiler.
    this function will be used to request more tokens from the
    user of an interpreter, or if the compiler needs more input
    from a file being compiled. but all of that will need to be
    decided later, for the various frontends. given that the
    extensions mentioned above are in fact usefull, we will leave
    this function alone until we need it.

    buf->[c0, c1, c2, .., ctoken-1, ctoken, .., cend-1, cend, .., cbuf+SCANNER_BUF_SZ]

    ->token points to the character just past the last token processed.
    (in other words, at the beginning of the next token to process.)
    the difference between the start of the array (->buf) and
    the end of the last token (->token) is the space currently
    being occupied by processed characters in the array.
    (it is the 'processed' text.)

    available is the slots in the buffer left which can be filled
    with more characters. it is the total slots in the array available
    minus the slots taken up by the unprocessed slots sitting
    between the end of the last token (->token) and the end of
    the buffered input (->end) (the 'unprocessed' characters as it were)

    so the goal of this function is to shift the unprocessed
    input left in the buffer to the bottom of the array, and
    fill the now available space with more input from the input FILE.
  */
  size_t charsRead = 0;
  size_t processed = scanner->token - scanner->buf;
  size_t available = SCANNER_BUF_SZ - (scanner->end - scanner->token);

  if (available < 1) return -1;

  memmove(scanner->buf, scanner->token, SCANNER_BUF_SZ - processed);
  scanner->end    -= processed;
  scanner->cursor -= processed;
  scanner->token  -= processed;

  if (scanner->is_stdin)
    printf(":> ");
  charsRead = getline(&(scanner->end), &available, scanner->yyin);

  if (charsRead < 0) {
    /*
    getline returns -1 after errors and eof;
    so distinguish between real errors and
    the known case of end of input.
     */
    if (!feof(scanner->yyin)) {
      perror("yylex:getline");
      exit(1);
    }
  }
  else {
    scanner->end += charsRead;
    scanner->end[0] = 0;
  }

  return charsRead;
}

char* yytext(Scanner* scanner)
{
    return strndup(scanner->token, scanner->cursor - scanner->token);
}

StrLoc* yylloc(Scanner* scanner)
{
    return (StrLoc*)(&(scanner->yylloc));
}


void update_location(StrLoc* llocp, char* token, int length)
{
    llocp->first_line   = llocp->last_line;
    llocp->first_column = llocp->last_column;

    for (int i = 0; i < length; i++) {
        if (token[i] == '\n') {
            llocp->last_line++;
            llocp->last_column = 1;
        }
        else {
            llocp->last_column++;
        }
    }
}



/*
typedef struct Scanner {
	char  buf[SCANNER_BUF_SZ + 1];
    char* end;
    char* cursor;
	char* marker;
    char* token;
	unsigned int yyaccept;
	int state;
	FILE* yyin;
	char  yych;
	bool  is_stdin;
	struct {
		int first_line;
		int first_column;
		int last_line;
		int last_column;
	} yylloc;
} Scanner;

    needs of re2c:

    yych holds current input character.
    YYCTYPE is the type of yych

    YYCURSOR is of type YYCTYPE*, and is used to search for matches

    YYLIMIT is of type YYCTYPE*, and is used to delimit the end of the buffer.

    YYMARKER is of type YYCTYPE* and is used to backup the cursor after a successful
                match, in certain circumstances.


from the re2c manual
the default scanner behavior in terms of the generic interface.
these are the basic scanner primitives which drive the algorithm:
#define  YYPEEK ()         *YYCURSOR
#define  YYSKIP ()         ++YYCURSOR
#define  YYBACKUP ()       YYMARKER = YYCURSOR
#define  YYRESTORE ()      YYCURSOR = YYMARKER
this is the check for the end of the input:
#define  YYLESSTHAN (n)    YYLIMIT - YYCURSOR < n
these primitives are only used to support specific scanner features
in re2c, specifically, s-tags and m-tags, which from the docs are
used to implement "staDFA delayed store actions". which I do not know
what that is, but I am not using them so eh.
the context (CTX) primitives are used to support the specific
regular expression R \ S which is an R followed by an S but the S
is not consumed. (which is why it takes another pointer to support.)
(notice how the scanner data structure doesn't even define this context
 ptr, because it doesn't need to.)
#define  YYBACKUPCTX ()    YYCTXMARKER = YYCURSOR
#define  YYRESTORECTX ()   YYCURSOR = YYCTXMARKER
#define  YYRESTORERAG (t)  YYCURSOR = t
#define  YYSTAGP (t)       t = YYCURSOR
#define  YYSTAGPD (t)      t = YYCURSOR - 1
#define  YYSTAGN (t)       t = NULL
*/


#line 219 "lexer.re"


/*
    we want to support reading from an input source
    that may not give us all of the input in a single go.
    because that makes extending the compiler to handle
    very large files, multiple input sources, and reading
    input from an unreliable source like a socket, possible.
    (making the parser with this semantics from the beginning
    should work to say the interpreter semantics neatly,
    (as the user may enter half an expression on one call to
    getline and the other half on the second call.)
    and allow extension to be easier. simply because there will
    be less to change to fit with the extensions (each a situation
    in which the full input doesn't fit in the memory buffer
    foor parsing.).)

    we could tie the scanner and lexer together if we imagine the existance
    of the ';' symbol with the meaning of [term ';' term] in the grammar.

    this gives us an explicit lexical symbol with the meaning 'end-of-term'.

    we then allow empty expressions; by allowing an ending
    token to appear immediately as a primary
    leading to said empty expression. we could
    have a user insert a semicolon to 'end' an expression in
    the language. and silently we would parse this as
    (user input) ';' empty

    we could also parse an empty buffer as an empty term.
    and that can stop the parse.

    but we need to be very careful. I don't want every
    lone term to parse forever.

    - enter nothing, parser returns an empty term
        - typechecker types it as nothing,
        - evaluator evaluates it to nothing,
    - enter something valid, keep trying to
        fill the buffer until we reach an end token.

    to recap:
    terms like "(\x=>x)" will cause the parser to return for
    more input unless ended with a ';' token. (essentially
    the parser greedily wants to assume you are going to
    postfix an application or binop after a valid term,
    as that is it's required behavior when parsing some long
    expression, we as programmers want to have as much
    control over what get's parsed as possible, so the explicit
    'period' character (homomorphically (what i would call metaphorically
    if it were between two entities in reality being described by language.))
     ";" makes the most sense.)
    and "" will cause the parser to end immediately.
    this allows a user to enter a single full term by
    ending it with a ';'. (and if they enter nothing
    the parser will end, and the program will execute
    default no-op behavior. which is also technically what it
    does when evaluating the rhs of the semicolon.)
    we won't immediately try and construct any node, as the
    yyfill call is implicitly associated with reaching the end
    of input from the lexer. whereby it returns MORE.
    i think this means that the trigger for yymore needs to
    be lifted out of the scanner by way of making it reentrant,
    and the parser needs to call yyfill itself when it encounters
    the MORE token.
    then we need to care about a yymore that doesn't get any more,
    and wether that situation is an error or not.
    which depends on where we are in a parse. (im not sure what
    exactly to base this boolean judgement on. some flag allocated
    for this purpose? some particular arrangement of the already
    allocated memory?)
*/



/*
    we use the Generic re2c Interface to allow us to
    store the lexer variables in our own structure,
    because the lexer will eventually be reentrant.
    and if the lexer is specified as reentrant, it
    expects the user to store them like this,
    (but this current use case is not documented at all.
        at least explicitly.)
*/
#define YYPEEK()       *scanner->cursor
#define YYSKIP()       ++(scanner->cursor)
#define YYBACKUP()     scanner->marker = scanner->cursor
#define YYRESTORE()    scanner->cursor = scanner->marker
#define YYBACKUPCTX()  scanner->mrkctx = scanner->cursor
#define YYRESTORECTX() scanner->cursor = scanner->mrkctx
#define YYLESSTHAN(n)  (scanner->end - scanner->cursor) < n

int yylex(Parser* parser, Scanner* scanner)
{
loop:
  scanner->token = scanner->cursor;
  
#line 315 "lexer.c"
{
	char yych;
	yych = YYPEEK ();
	switch (yych) {
	case '\t':
	case ' ':	goto yy4;
	case '\n':	goto yy6;
	case '%':	goto yy8;
	case '(':	goto yy10;
	case ')':	goto yy12;
	case '*':	goto yy14;
	case '+':	goto yy16;
	case '-':	goto yy18;
	case '/':	goto yy20;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	case ':':	goto yy25;
	case ';':	goto yy27;
	case '=':	goto yy29;
	case 'A':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'g':
	case 'h':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	case 'B':	goto yy33;
	case 'I':	goto yy34;
	case 'N':	goto yy35;
	case '\\':	goto yy36;
	case 'e':	goto yy38;
	case 'f':	goto yy39;
	case 'i':	goto yy40;
	case 'n':	goto yy41;
	case 't':	goto yy42;
	case '{':	goto yy43;
	case '}':	goto yy45;
	default:
		if (YYLESSTHAN (1)) {
			goto yyeof;
		}
		goto yy2;
	}
yy2:
	YYSKIP ();
yy3:
#line 321 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ERR; }
#line 409 "lexer.c"
yy4:
	YYSKIP ();
#line 323 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); goto loop; }
#line 414 "lexer.c"
yy6:
	YYSKIP ();
#line 324 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NEWLN; }
#line 419 "lexer.c"
yy8:
	YYSKIP ();
#line 352 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 424 "lexer.c"
yy10:
	YYSKIP ();
#line 354 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LPAREN; }
#line 429 "lexer.c"
yy12:
	YYSKIP ();
#line 355 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RPAREN; }
#line 434 "lexer.c"
yy14:
	YYSKIP ();
#line 350 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 439 "lexer.c"
yy16:
	YYSKIP ();
#line 348 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 444 "lexer.c"
yy18:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy47;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy19;
	}
yy19:
#line 349 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 458 "lexer.c"
yy20:
	YYSKIP ();
#line 351 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 463 "lexer.c"
yy22:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy24;
	}
yy24:
#line 327 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT; }
#line 486 "lexer.c"
yy25:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '=':	goto yy49;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy26;
	}
yy26:
#line 335 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLON; }
#line 500 "lexer.c"
yy27:
	YYSKIP ();
#line 353 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return SEMICOLON; }
#line 505 "lexer.c"
yy29:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy51;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy3;
	}
yy30:
	YYSKIP ();
	yych = YYPEEK ();
yy31:
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	}
yy32:
#line 358 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ID; }
#line 592 "lexer.c"
yy33:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'o':	goto yy53;
	default:	goto yy31;
	}
yy34:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'n':	goto yy54;
	default:	goto yy31;
	}
yy35:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'i':	goto yy55;
	default:	goto yy31;
	}
yy36:
	YYSKIP ();
#line 337 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BSLASH; }
#line 630 "lexer.c"
yy38:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy56;
	default:	goto yy31;
	}
yy39:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'a':	goto yy57;
	default:	goto yy31;
	}
yy40:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'f':	goto yy58;
	default:	goto yy31;
	}
yy41:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'i':	goto yy60;
	default:	goto yy31;
	}
yy42:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'h':	goto yy61;
	case 'r':	goto yy62;
	default:	goto yy31;
	}
yy43:
	YYSKIP ();
#line 356 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LBRACE; }
#line 691 "lexer.c"
yy45:
	YYSKIP ();
#line 357 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RBRACE; }
#line 696 "lexer.c"
yy47:
	YYSKIP ();
#line 347 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 701 "lexer.c"
yy49:
	YYSKIP ();
#line 336 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLONEQUALS; }
#line 706 "lexer.c"
yy51:
	YYSKIP ();
#line 338 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return REQARROW; }
#line 711 "lexer.c"
yy53:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'o':	goto yy63;
	default:	goto yy31;
	}
yy54:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 't':	goto yy64;
	default:	goto yy31;
	}
yy55:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy66;
	default:	goto yy31;
	}
yy56:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 's':	goto yy68;
	default:	goto yy31;
	}
yy57:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy69;
	default:	goto yy31;
	}
yy58:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy59;
	}
yy59:
#line 332 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return IF; }
#line 842 "lexer.c"
yy60:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy70;
	default:	goto yy31;
	}
yy61:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'e':	goto yy72;
	default:	goto yy31;
	}
yy62:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'u':	goto yy73;
	default:	goto yy31;
	}
yy63:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'l':	goto yy74;
	default:	goto yy31;
	}
yy64:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy65;
	}
yy65:
#line 328 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT_TYPE; }
#line 962 "lexer.c"
yy66:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy67;
	}
yy67:
#line 326 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL_TYPE; }
#line 1038 "lexer.c"
yy68:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'e':	goto yy76;
	default:	goto yy31;
	}
yy69:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 's':	goto yy78;
	default:	goto yy31;
	}
yy70:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy71;
	}
yy71:
#line 325 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL; }
#line 1136 "lexer.c"
yy72:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'n':	goto yy79;
	default:	goto yy31;
	}
yy73:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'e':	goto yy81;
	default:	goto yy31;
	}
yy74:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy75;
	}
yy75:
#line 331 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BOOL_TYPE; }
#line 1234 "lexer.c"
yy76:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy77;
	}
yy77:
#line 334 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ELSE; }
#line 1310 "lexer.c"
yy78:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy32;
	case 'e':	goto yy83;
	default:	goto yy31;
	}
yy79:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy80;
	}
yy80:
#line 333 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return THEN; }
#line 1397 "lexer.c"
yy81:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy82;
	}
yy82:
#line 329 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return TRUE; }
#line 1473 "lexer.c"
yy83:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy30;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy84;
	}
yy84:
#line 330 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return FALSE; }
#line 1549 "lexer.c"
yyeof:
#line 322 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return END; }
#line 1553 "lexer.c"
}
#line 359 "lexer.re"

}








































/* ---------------------------------------------------------------- */
