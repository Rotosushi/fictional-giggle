/* Generated by re2c 1.3 on Thu Jul  2 16:20:34 2020 */
#line 1 "lexer.re"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "lexer.h"
#include "parser.h"
#include "error.h"


Scanner* createScanner(FILE* in)
{
    Scanner* scnr = (Scanner*)malloc(sizeof(Scanner));
    memset (scnr->buf, 0, SCANNER_BUF_SZ + 1);
    scnr->yych = 0;
    scnr->end = scnr->cursor = scnr->token = scnr->marker = scnr->buf + SCANNER_BUF_SZ;
    scnr->yyaccept = 0;
    scnr->state = -1;
    if (in) {
      if (in == stdin)
        scnr->is_stdin = true;
      else
        scnr->is_stdin = false;

      scnr->yyin = in;
    }
    else {
      scnr->yyin = stdin;
      scnr->is_stdin = true;
    }
    return scnr;
}

void destroyScanner(Scanner* scanner)
{
  free(scanner);
}

void yysetbuffer(Scanner* scnr, char* text, int len)
{
    if (len > SCANNER_BUF_SZ)
        error_abort("cannot buffer input text, aborting", __FILE__, __LINE__);

    memset (scnr->buf, 0, SCANNER_BUF_SZ);
    memcpy (scnr->buf, text, len);

    scnr->cursor = scnr->marker = scnr->mrkctx = scnr->token = scnr->buf;
    /*
        I removed a (+ 1) from the end of this line,
        thinking that it may solve the issue where the
        lexer inserts the ERR token when lexing the
        NEWLINE at the end of the buffer (filled with
        text from the user via getline.)
    */
    scnr->end = scnr->buf + len;
}

int yyfill(Scanner* scanner)
{
  /*
    technically the new scanner never calls YYFILL by definition,
    so this function is always useless. but it is necessary if
    we ever want to write a stream frontend for the compiler.
    this function will be used to request more tokens from the
    user of an interpreter, or if the compiler needs more input
    from a file being compiled. but all of that will need to be
    decided later, for the various frontends. given that the
    extensions mentioned above are in fact usefull, we will leave
    this function alone until we need it.

    buf->[c0, c1, c2, .., ctoken-1, ctoken, .., cend-1, cend, .., cbuf+SCANNER_BUF_SZ]

    ->token points to the character just past the last token processed.
    (in other words, at the beginning of the next token to process.)
    the difference between the start of the array (->buf) and
    the end of the last token (->token) is the space currently
    being occupied by processed characters in the array.
    (it is the 'processed' text.)

    available is the slots in the buffer left which can be filled
    with more characters. it is the total slots in the array available
    minus the slots taken up by the unprocessed slots sitting
    between the end of the last token (->token) and the end of
    the buffered input (->end) (the 'unprocessed' characters as it were)

    so the goal of this function is to shift the unprocessed
    input left in the buffer to the bottom of the array, and
    fill the now available space with more input from the input FILE.
  */
  size_t charsRead = 0;
  size_t processed = scanner->token - scanner->buf;
  size_t available = SCANNER_BUF_SZ - (scanner->end - scanner->token);

  if (available < 1) return -1;

  memmove(scanner->buf, scanner->token, SCANNER_BUF_SZ - processed);
  scanner->end    -= processed;
  scanner->cursor -= processed;
  scanner->token  -= processed;

  if (scanner->is_stdin)
    printf(":> ");
  charsRead = getline(&(scanner->end), &available, scanner->yyin);

  if (charsRead < 0) {
    /*
    getline returns -1 after errors and eof;
    so distinguish between real errors and
    the known case of end of input.
     */
    if (!feof(scanner->yyin)) {
      perror("yylex:getline");
      exit(1);
    }
  }
  else {
    scanner->end += charsRead;
    scanner->end[0] = 0;
  }

  return charsRead;
}

char* yytext(Scanner* scanner)
{
    return strndup(scanner->token, scanner->cursor - scanner->token);
}

StrLoc* yylloc(Scanner* scanner)
{
    return (StrLoc*)(&(scanner->yylloc));
}


void update_location(StrLoc* llocp, char* token, int length)
{
    llocp->first_line   = llocp->last_line;
    llocp->first_column = llocp->last_column;

    for (int i = 0; i < length; i++) {
        if (token[i] == '\n') {
            llocp->last_line++;
            llocp->last_column = 1;
        }
        else {
            llocp->last_column++;
        }
    }
}



/*
typedef struct Scanner {
	char  buf[SCANNER_BUF_SZ + 1];
    char* end;
    char* cursor;
	char* marker;
    char* token;
	unsigned int yyaccept;
	int state;
	FILE* yyin;
	char  yych;
	bool  is_stdin;
	struct {
		int first_line;
		int first_column;
		int last_line;
		int last_column;
	} yylloc;
} Scanner;

    needs of re2c:

    yych holds current input character.
    YYCTYPE is the type of yych

    YYCURSOR is of type YYCTYPE*, and is used to search for matches

    YYLIMIT is of type YYCTYPE*, and is used to delimit the end of the buffer.

    YYMARKER is of type YYCTYPE* and is used to backup the cursor after a successful
                match, in certain circumstances.


from the re2c manual
the default scanner behavior in terms of the generic interface.
these are the basic scanner primitives which drive the algorithm:
#define  YYPEEK ()         *YYCURSOR
#define  YYSKIP ()         ++YYCURSOR
#define  YYBACKUP ()       YYMARKER = YYCURSOR
#define  YYRESTORE ()      YYCURSOR = YYMARKER
this is the check for the end of the input:
#define  YYLESSTHAN (n)    YYLIMIT - YYCURSOR < n
these primitives are only used to support specific scanner features
in re2c, specifically, s-tags and m-tags, which from the docs are
used to implement "staDFA delayed store actions". which I do not know
what that is, but I am not using them so eh.
the context (CTX) primitives are used to support the specific
regular expression R \ S which is an R followed by an S but the S
is not consumed. (which is why it takes another pointer to support.)
(notice how the scanner data structure doesn't even define this context
 ptr, because it doesn't need to.)
#define  YYBACKUPCTX ()    YYCTXMARKER = YYCURSOR
#define  YYRESTORECTX ()   YYCURSOR = YYCTXMARKER
#define  YYRESTORERAG (t)  YYCURSOR = t
#define  YYSTAGP (t)       t = YYCURSOR
#define  YYSTAGPD (t)      t = YYCURSOR - 1
#define  YYSTAGN (t)       t = NULL
*/


#line 219 "lexer.re"


/*
    we want to support reading from an input source
    that may not give us all of the input in a single go.
    because that makes extending the compiler to handle
    very large files, multiple input sources, and reading
    input from an unreliable source like a socket, possible.
    (making the parser with this semantics from the beginning
    should work to say the interpreter semantics neatly,
    (as the user may enter half an expression on one call to
    getline and the other half on the second call.)
    and allow extension to be easier. simply because there will
    be less to change to fit with the extensions (each a situation
    in which the full input doesn't fit in the memory buffer
    foor parsing.).)

    we could tie the scanner and lexer together if we imagine the existance
    of the ';' symbol with the meaning of [term ';' term] in the grammar.

    this gives us an explicit lexical symbol with the meaning 'end-of-term'.

    we then allow empty expressions; by allowing an ending
    token to appear immediately as a primary
    leading to said empty expression. we could
    have a user insert a semicolon to 'end' an expression in
    the language. and silently we would parse this as
    (user input) ';' empty

    we could also parse an empty buffer as an empty term.
    and that can stop the parse.

    but we need to be very careful. I don't want every
    lone term to parse forever.

    - enter nothing, parser returns an empty term
        - typechecker types it as nothing,
        - evaluator evaluates it to nothing,
    - enter something valid, keep trying to
        fill the buffer until we reach an end token.

    to recap:
    terms like "(\x=>x)" will cause the parser to return for
    more input unless ended with a ';' token. (essentially
    the parser greedily wants to assume you are going to
    postfix an application or binop after a valid term,
    as that is it's required behavior when parsing some long
    expression, we as programmers want to have as much
    control over what get's parsed as possible, so the explicit
    'period' character (homomorphically (what i would call metaphorically
    if it were between two entities in reality being described by language.))
     ";" makes the most sense.)
    and "" will cause the parser to end immediately.
    this allows a user to enter a single full term by
    ending it with a ';'. (and if they enter nothing
    the parser will end, and the program will execute
    default no-op behavior. which is also technically what it
    does when evaluating the rhs of the semicolon.)
    we won't immediately try and construct any node, as the
    yyfill call is implicitly associated with reaching the end
    of input from the lexer. whereby it returns MORE.
    i think this means that the trigger for yymore needs to
    be lifted out of the scanner by way of making it reentrant,
    and the parser needs to call yyfill itself when it encounters
    the MORE token.
    then we need to care about a yymore that doesn't get any more,
    and wether that situation is an error or not.
    which depends on where we are in a parse. (im not sure what
    exactly to base this boolean judgement on. some flag allocated
    for this purpose? some particular arrangement of the already
    allocated memory?)
*/



/*
    we use the Generic re2c Interface to allow us to
    store the lexer variables in our own structure,
    because the lexer will eventually be reentrant.
    and if the lexer is specified as reentrant, it
    expects the user to store them like this,
    (but this current use case is not documented at all.
        at least explicitly.)
*/
#define YYPEEK()       *scanner->cursor
#define YYSKIP()       ++(scanner->cursor)
#define YYBACKUP()     scanner->marker = scanner->cursor
#define YYRESTORE()    scanner->cursor = scanner->marker
#define YYBACKUPCTX()  scanner->mrkctx = scanner->cursor
#define YYRESTORECTX() scanner->cursor = scanner->mrkctx
#define YYLESSTHAN(n)  (scanner->end - scanner->cursor) < n

int yylex(Parser* parser, Scanner* scanner)
{
loop:
  scanner->token = scanner->cursor;
  
#line 315 "lexer.c"
{
	char yych;
	yych = YYPEEK ();
	switch (yych) {
	case '\t':
	case ' ':	goto yy4;
	case '\n':	goto yy6;
	case '%':	goto yy8;
	case '(':	goto yy10;
	case ')':	goto yy12;
	case '*':	goto yy14;
	case '+':	goto yy16;
	case '-':	goto yy18;
	case '/':	goto yy20;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	case ':':	goto yy25;
	case ';':	goto yy27;
	case '=':	goto yy29;
	case 'A':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'g':
	case 'h':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	case 'B':	goto yy34;
	case 'I':	goto yy35;
	case 'N':	goto yy36;
	case '\\':	goto yy37;
	case 'e':	goto yy39;
	case 'f':	goto yy40;
	case 'i':	goto yy41;
	case 'n':	goto yy42;
	case 't':	goto yy43;
	case '{':	goto yy44;
	case '}':	goto yy46;
	default:
		if (YYLESSTHAN (1)) {
			goto yyeof;
		}
		goto yy2;
	}
yy2:
	YYSKIP ();
yy3:
#line 321 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ERR; }
#line 409 "lexer.c"
yy4:
	YYSKIP ();
#line 323 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); goto loop; }
#line 414 "lexer.c"
yy6:
	YYSKIP ();
#line 324 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NEWLN; }
#line 419 "lexer.c"
yy8:
	YYSKIP ();
#line 353 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 424 "lexer.c"
yy10:
	YYSKIP ();
#line 355 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LPAREN; }
#line 429 "lexer.c"
yy12:
	YYSKIP ();
#line 356 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RPAREN; }
#line 434 "lexer.c"
yy14:
	YYSKIP ();
#line 351 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 439 "lexer.c"
yy16:
	YYSKIP ();
#line 349 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 444 "lexer.c"
yy18:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy48;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy19;
	}
yy19:
#line 350 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 458 "lexer.c"
yy20:
	YYSKIP ();
#line 352 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 463 "lexer.c"
yy22:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy22;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy24;
	}
yy24:
#line 327 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT; }
#line 486 "lexer.c"
yy25:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '=':	goto yy50;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy26;
	}
yy26:
#line 335 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLON; }
#line 500 "lexer.c"
yy27:
	YYSKIP ();
#line 354 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return SEMICOLON; }
#line 505 "lexer.c"
yy29:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '>':	goto yy52;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy30;
	}
yy30:
#line 347 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 519 "lexer.c"
yy31:
	YYSKIP ();
	yych = YYPEEK ();
yy32:
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	}
yy33:
#line 359 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ID; }
#line 596 "lexer.c"
yy34:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'o':	goto yy54;
	default:	goto yy32;
	}
yy35:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'n':	goto yy55;
	default:	goto yy32;
	}
yy36:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'i':	goto yy56;
	default:	goto yy32;
	}
yy37:
	YYSKIP ();
#line 337 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BSLASH; }
#line 634 "lexer.c"
yy39:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'l':	goto yy57;
	default:	goto yy32;
	}
yy40:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'a':	goto yy58;
	default:	goto yy32;
	}
yy41:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'f':	goto yy59;
	default:	goto yy32;
	}
yy42:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'i':	goto yy61;
	default:	goto yy32;
	}
yy43:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'h':	goto yy62;
	case 'r':	goto yy63;
	default:	goto yy32;
	}
yy44:
	YYSKIP ();
#line 357 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LBRACE; }
#line 695 "lexer.c"
yy46:
	YYSKIP ();
#line 358 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RBRACE; }
#line 700 "lexer.c"
yy48:
	YYSKIP ();
#line 348 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return OPERATOR; }
#line 705 "lexer.c"
yy50:
	YYSKIP ();
#line 336 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLONEQUALS; }
#line 710 "lexer.c"
yy52:
	YYSKIP ();
#line 338 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return REQARROW; }
#line 715 "lexer.c"
yy54:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'o':	goto yy64;
	default:	goto yy32;
	}
yy55:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 't':	goto yy65;
	default:	goto yy32;
	}
yy56:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'l':	goto yy67;
	default:	goto yy32;
	}
yy57:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 's':	goto yy69;
	default:	goto yy32;
	}
yy58:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'l':	goto yy70;
	default:	goto yy32;
	}
yy59:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy60;
	}
yy60:
#line 332 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return IF; }
#line 846 "lexer.c"
yy61:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'l':	goto yy71;
	default:	goto yy32;
	}
yy62:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'e':	goto yy73;
	default:	goto yy32;
	}
yy63:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'u':	goto yy74;
	default:	goto yy32;
	}
yy64:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'l':	goto yy75;
	default:	goto yy32;
	}
yy65:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy66;
	}
yy66:
#line 328 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return INT_TYPE; }
#line 966 "lexer.c"
yy67:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy68;
	}
yy68:
#line 326 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL_TYPE; }
#line 1042 "lexer.c"
yy69:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'e':	goto yy77;
	default:	goto yy32;
	}
yy70:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 's':	goto yy79;
	default:	goto yy32;
	}
yy71:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy72;
	}
yy72:
#line 325 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL; }
#line 1140 "lexer.c"
yy73:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'n':	goto yy80;
	default:	goto yy32;
	}
yy74:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'e':	goto yy82;
	default:	goto yy32;
	}
yy75:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy76;
	}
yy76:
#line 331 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BOOL_TYPE; }
#line 1238 "lexer.c"
yy77:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy78;
	}
yy78:
#line 334 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ELSE; }
#line 1314 "lexer.c"
yy79:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case 0x00:
		if (YYLESSTHAN (1)) {
		}
		goto yy33;
	case 'e':	goto yy84;
	default:	goto yy32;
	}
yy80:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy81;
	}
yy81:
#line 333 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return THEN; }
#line 1401 "lexer.c"
yy82:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy83;
	}
yy83:
#line 329 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return TRUE; }
#line 1477 "lexer.c"
yy84:
	YYSKIP ();
	yych = YYPEEK ();
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy31;
	default:
		if (YYLESSTHAN (1)) {
		}
		goto yy85;
	}
yy85:
#line 330 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return FALSE; }
#line 1553 "lexer.c"
yyeof:
#line 322 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return END; }
#line 1557 "lexer.c"
}
#line 360 "lexer.re"

}








































/* ---------------------------------------------------------------- */
