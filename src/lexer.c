/* Generated by re2c 1.3 on Fri Jun  5 17:23:29 2020 */
#line 1 "lexer.re"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "lexer.h"
#include "parser.h"


Scanner* createScanner(FILE* in)
{
    Scanner* scnr = (Scanner*)malloc(sizeof(Scanner));
    memset (scnr->buf, 0, SCANNER_BUF_SZ + 1);
    scnr->yych = 0;
    scnr->end = scnr->cursor = scnr->token = scnr->marker = scnr->buf + SCANNER_BUF_SZ;
    scnr->yyaccept = 0;
    scnr->state = -1;
    if (in) {
      if (in == stdin)
        scnr->is_stdin = true;
      else
        scnr->is_stdin = false;

      scnr->yyin = in;
    }
    else {
      scnr->yyin = stdin;
      scnr->is_stdin = true;
    }
    return scnr;
}

void destroyScanner(Scanner* scanner)
{
  free(scanner);
}

int yyfill(Scanner* scanner)
{
  /*
    buf [c0, c1, c2, .., ctoken-1, ctoken, .., cend-1, cend, .., buf+SCANNER_BUF_SZ]

    ->token points to the character just past the last token processed.
    (in other words, at the beginning of the next token to process.)
    the difference between the start of the array (->buf) and
    the end of the last token (->token) is the space currently
    being occupied by processed characters in the array.
    (its the 'processed' text.)

    available is the slots available in the buffer to fill
    with more characters. it is the total slots in the array available
    minus the slots taken up by the unprocessed slots sitting
    between the end of the last token (->token) and the end of
    the buffered input (->end)

    so the goal of this function is to shift the unprocessed
    input left in the buffer to the bottom of the array, and
    fill the available space with more input from the in FILE.
  */
  size_t charsRead = 0;
  size_t processed = scanner->token - scanner->buf;
  size_t available = SCANNER_BUF_SZ - (scanner->end - scanner->token);

  if (available < 1) return -1;

  memmove(scanner->buf, scanner->token, SCANNER_BUF_SZ - processed);
  scanner->end    -= processed;
  scanner->cursor -= processed;
  scanner->token  -= processed;

  if (scanner->is_stdin)
    printf(":> ");
  charsRead = getline(&(scanner->end), &available, scanner->yyin);

  if (charsRead < 0) {
    /*
    getline returns -1 after errors and eof;
    so distinguish between real errors and
    the known case of end of input.
     */
    if (!feof(scanner->yyin)) {
      perror("yylex:getline");
      exit(1);
    }
  }
  else {
    scanner->end += charsRead;
    scanner->end[0] = 0;
  }

  return charsRead;
}

char* yytext(Scanner* scanner)
{
    return strndup(scanner->token, scanner->cursor - scanner->token);
}

StrLoc* yylloc(Scanner* scanner)
{
    return (StrLoc*)(&(scanner->yylloc));
}


void update_location(StrLoc* llocp, char* token, int length)
{
    llocp->first_line   = llocp->last_line;
    llocp->first_column = llocp->last_column;

    for (int i = 0; i < length; i++) {
        if (token[i] == '\n') {
            llocp->last_line++;
            llocp->last_column = 1;
        }
        else {
            llocp->last_column++;
        }
    }
}

#define YYGETSTATE()  scanner->state
#define YYSETSTATE(s) scanner->state = s
#define YYMARKER      scanner->marker
#define yyaccept      scanner->yyaccept
#define YYFILL()      return MORE
#line 134 "lexer.re"




int yylex(Parser* parser, Scanner* scanner, struct StrLoc* llocp)
{
  switch (YYGETSTATE()) {
default: goto yy0;
case 0: if (scanner->end <= scanner->cursor) goto yyeof0; goto yyFillLabel0;
case 1: if (scanner->end <= scanner->cursor) goto yyeof1; goto yyFillLabel1;
case 2: if (scanner->end <= scanner->cursor) goto yyeof2; goto yyFillLabel2;
case 3: if (scanner->end <= scanner->cursor) goto yyeof3; goto yyFillLabel3;
case 4: if (scanner->end <= scanner->cursor) goto yyeof4; goto yyFillLabel4;
case 5: if (scanner->end <= scanner->cursor) goto yyeof5; goto yyFillLabel5;
case 6: if (scanner->end <= scanner->cursor) goto yyeof6; goto yyFillLabel6;
}

  scanner->token = scanner->cursor;
loop:
  
#line 151 "lexer.c"

yy0:
yyFillLabel0:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case '\t':
	case '\n':
	case '\r':
	case ' ':	goto yy4;
	case '(':	goto yy6;
	case ')':	goto yy8;
	case '-':	goto yy10;
	case ':':	goto yy11;
	case ';':	goto yy13;
	case '=':	goto yy15;
	case '\\':	goto yy16;
	case '_':
	case 'a':
	case 'h':
	case 'l':
	case 'p':	goto yy18;
	case 'n':	goto yy21;
	case '{':	goto yy22;
	case '}':	goto yy24;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(0);
			YYFILL();
			yyeof0:;
			goto yyeof;
		}
		goto yy2;
	}
yy2:
	++scanner->cursor;
yy3:
#line 151 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ERR; }
#line 190 "lexer.c"
yy4:
	++scanner->cursor;
#line 150 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); goto loop; }
#line 195 "lexer.c"
yy6:
	++scanner->cursor;
#line 160 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LPAREN; }
#line 200 "lexer.c"
yy8:
	++scanner->cursor;
#line 161 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RPAREN; }
#line 205 "lexer.c"
yy10:
	++scanner->cursor;
yyFillLabel1:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case '>':	goto yy26;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(1);
			YYFILL();
			yyeof1:;
		}
		goto yy3;
	}
yy11:
	++scanner->cursor;
yyFillLabel2:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case '=':	goto yy28;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(2);
			YYFILL();
			yyeof2:;
		}
		goto yy12;
	}
yy12:
#line 154 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLON; }
#line 237 "lexer.c"
yy13:
	++scanner->cursor;
#line 159 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return SEMICOLON; }
#line 242 "lexer.c"
yy15:
	++scanner->cursor;
yyFillLabel3:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case '>':	goto yy30;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(3);
			YYFILL();
			yyeof3:;
		}
		goto yy3;
	}
yy16:
	++scanner->cursor;
#line 156 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return BSLASH; }
#line 261 "lexer.c"
yy18:
	++scanner->cursor;
yyFillLabel4:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case 'I':
	case 'd':
	case 'e':
	case 'h':
	case 'n':
	case 'p':
	case 'y':	goto yy18;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(4);
			YYFILL();
			yyeof4:;
		}
		goto yy20;
	}
yy20:
#line 164 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return ID; }
#line 285 "lexer.c"
yy21:
	YYMARKER = ++scanner->cursor;
yyFillLabel5:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case 'i':	goto yy32;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(5);
			YYFILL();
			yyeof5:;
		}
		goto yy3;
	}
yy22:
	++scanner->cursor;
#line 162 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return LBRACE; }
#line 304 "lexer.c"
yy24:
	++scanner->cursor;
#line 163 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RBRACE; }
#line 309 "lexer.c"
yy26:
	++scanner->cursor;
#line 157 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return RARROW; }
#line 314 "lexer.c"
yy28:
	++scanner->cursor;
#line 155 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return COLONEQUALS; }
#line 319 "lexer.c"
yy30:
	++scanner->cursor;
#line 158 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return REQARROW; }
#line 324 "lexer.c"
yy32:
	++scanner->cursor;
yyFillLabel6:
	scanner->yych = *scanner->cursor;
	switch (scanner->yych) {
	case 'l':	goto yy34;
	default:
		if (scanner->end <= scanner->cursor) {
			YYSETSTATE(6);
			YYFILL();
			yyeof6:;
		}
		goto yy33;
	}
yy33:
	scanner->cursor = YYMARKER;
	goto yy3;
yy34:
	++scanner->cursor;
#line 153 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return NIL; }
#line 346 "lexer.c"
yyeof:
#line 152 "lexer.re"
	{ update_location((StrLoc*)&scanner->yylloc, scanner->token, scanner->cursor - scanner->token); return END; }
#line 350 "lexer.c"
#line 165 "lexer.re"

}








































/* ---------------------------------------------------------------- */
