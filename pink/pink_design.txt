
%% Zen
- a small yet expressive language, built for readability, ergonomics
- and easy parsing.

- logical consistency, one obvious way of doing things,
- easy to say what is easy to do.

- The goal is also not to create a 'pure' language, nor is the language
	'impure', this language is a collection of the most sensible features
	working together to express programming ideas ergonomically. The goal 
	is to have a clear (read: unambiguous), 
	concise(read: just enough characters to communicate, but not so many
	 that it becomes a chore to write and mentally parse. see: c++ templates),
	 and highly expressive language; 

- Dimensions of the language
	- Expressivity
		the language should enable programmers solve their problems, rather
		than solve the riddle of how to express what they want to say in the
		language.

		Programmers fluent in the language should be able to easily read what
		one another are saying and doing in their code. 
		common abstractions should have a common form
		common tasks should have a common form
		it should be easy to say what is easy to do 

	- Security
		The language doesn't exist in a vacuum, a robust, expressive language
		should be aware of the security concerns of a modern language. C is 
		exploitable because it is hard to write hardened code, and easy to 
		exploit interoperations between disperate programs. More complex languages
		are exploitable because their own operation is hard to understand.

	- Performance
		writing code that utilizes its resources effectively is difficult. writing
		interoperating abstractions that can utilize shared resources is difficult.
		performance modeling should be easy to do, and require minimal cognitive
		overhead. the shape of performance modeling is uniform in the time axis, 
		and on the space axis.

	- Maintainability
		Code that is written today, may be talking to code that is written 20
		years from now. This is not something that can be ignored. How does this
		affect the other dimensions, and how does the language assist programmers
		in this dimension.

	- Testing
		testing is a non-trivial aspect of development, that also has a uniform
		shape. How does this language assist programmers in testing their own code?
		in testing unknown code? 

- Cognitive Dimensions of Abstraction

Abstraction gradient 
    What are the minimum and maximum levels of abstraction exposed by the notation? 
	Can details be encapsulated?

Closeness of mapping 
    How closely does the notation correspond to the problem world?

Consistency 
    After part of the notation has been learned, how much of the rest can be 
	successfully guessed?

Diffuseness / terseness 
    How many symbols or how much space does the notation require to produce a 
	certain result or express a meaning?

Error-proneness 
    To what extent does the notation influence the likelihood of the user making 
	a mistake?

Hard mental operations 
    How much hard mental processing lies at the notational level, rather than at
	the semantic level? Are there places where the user needs to resort to fingers 
	or penciled annotation to keep track of what’s happening?

Hidden dependencies 
    Are dependencies between entities in the notation visible or hidden? Is every
	dependency indicated in both directions? Does a change in one area of the 
	notation lead to unexpected consequences?

Juxtaposability 
    Can different parts of the notation be compared side-by-side at the same time?

Premature commitment 
    Are there strong constraints on the order in which the user must complete 
	the tasks to use the system?

    Are there decisions that must be made before all the necessary information
	is available? Can those decisions be reversed or corrected later?

Progressive evaluation 
    How easy is it to evaluate and obtain feedback on an incomplete solution?

Role-expressiveness 
    How obvious is the role of each component of the notation in the solution as a 
	whole?

Secondary notation and escape from formalism 
    Can the notation carry extra information by means not related to syntax, such 
	as layout, color, or other cues?

Viscosity
    Are there any inherent barriers to change in the notation? How much effort 
	is required to make a change to a program expressed in the notation?

    This dimension can be further classified into the following types:

        'Knock-on viscosity' : a change in the code violates internal constraints
			in the program, whose resolution may violate further internal constraints.

        'Repetition viscosity' : a single action within the user’s conceptual 
			model requires many, repetitive device actions.

        'Scope viscosity' : a change in the size of the input data set requires 
			changes to the program structure itself.

Visibility 
    How readily can required parts of the notation be identified, 
	accessed and made visible?

creative ambiguity 
	does the notation encourage interpreting several meanings of 
	the same element?

indexing 
	are there elements to guide finding a specific part?

synopsis 
	"gestalt view" of the whole annotated structure

unevenness 
	some creation paths are easier than others, 
	which bias the expressed ideas in a developed artifact.

- "Stop telling me what you are saying and just say it!"
%% ~Zen

%% Thoughts on things
-- logical consistency : a function declaration should always look
	like a function declaration, a struct definition should always
	look like a struct declaration, a variable should have the 
	constraints that you tell it to have, this should permeate the
	design of the language. (instead of '~' and '!' we have '!' and '!!',
	because this lines up with the operator consistency of '&' and '&&',
	'|' and '||', and '^' and '^^')

-- this logical consistency lowers the learning curve, because there
	are less caveats to remember. This lessens cognitive burden and
	allows programmers to think about their problem, rather then how 
	to speak the language. This syntatic consistency will hopefully
	make the language easy to parse, this plus the small feature
	set, should make lisp stype macros easier to do. Lisp style
	macros in an imperitive language is the design space that I
	would like to explore. Eventually moving on to state machine 
	encoding, and to self modifying code. The easy to parse nature
	of the language will ease the further development with the language.
	and it should make it easier to disambiguate parse trees, and to
	make a deep learning neural network learn less rules before being
	able to generate code.

	a function declaration is disambiguated by the '->' operator
	either (<argument-list>) -> (<return-list>) {<block>} or
	(<argument-list>) -> {<block>}, with the omission of the
	(<return-list>) giving clear and syntactic indication to
	the programmer that the return values are going to be deduced 
	from the {<block>}. 
	
	This may help disambiguate between 
	constructors and function calls. 
	
	struct s :: {a: int; b: int;}

	a := s(5, 10);

	although 
	
	<identifier> <assignment-op> <type-name> '(' <argument-list> ')' ';'

	is only semantically different based on the type of the identifier

	<identifier> <assignment-op> <function-name> '(' <argument-list> ')' ';'

-- Type Constructors
	<type-name> '(' <argument-list> ')'

	type construction seems like a necessary language feature.
	c doesn't have this, and so requires seperate intitialization
	functions for more complex types. This separation of the type
	from it's intializer creates cognitive overhead. If types
	always have a constructor then this pairs each type with it's
	constructor function. This reduces the cognitive overhead
	of ensuring that types are valid after declaration 
	and initialization. 
	Explicit type construction looks like class construction
	but it is optional, and dynamic memory allocation should
	not occur by default. The default constructor should allocate
	space on the stack frame of the current function.
	

-- initializer lists for structs
-- vs. declared constructors like jai 

-- struct a :: {b: int, c: string}

	v1 : a{someint, somestring};
	v2 : a(someint, somestring);
	v3 := alloc (a, someint, somestring);
	v4 : a;
	v4 = alloc (a, someint, somestring);


-- a function call is so far the only syntactic construct that looks 
	like : <identifier> '(' <argument-list> ')' ';'
	if type construction calls a function, then the semantic difference
	between <function-name> '(' <argument-list> ')' ';'
	and     <type-name>     '(' <argument-list> ')' ';'
	might not be a problem.
		aside: This also seems like part of an argument for overloading
				functions.
	a function is always 'stored' in a variable, but we don't always
	want programmers to change top level functions, this is solved by
	the const assignment operator '::', this creates a constant binding

-- constness is always indicated through the '::' operator.
	constant functions:
		fun :: (a: int, b: int) -> {return a + b;}

	non-const functions:
		fun := (a: int, b: [] int) -> {return for i in b {c += a + i}}

	constant type definitions
		struct my_type :: { v: int; w: float; }

	constants in code
		my_constant :: "this string is constant";
		mY_other_constant :: 42;


	/// does variable capture help? or does it conflict
	    with internalized scoping rules too much?
	
	h :: () ->
	{
		variable := "smelly";
		{
			variable := "hello"; // there is no variable shadowing
			print(variable); // prints "hello"
		}
		print(variable);     // prints "smelly"

		{
			variable = "goodbye"; // error: variable is not declared in current scope
		}

		[variable]{ // here we capture the refrence to the outer variable
			variable := "code"; // reassign the contents of variable
			print(variable);    // prints "code"
		}
		print(variable); // prints "code"
	}

	// what does polymorphism look like?
	// double := (x: $T) -> {return T * T;}
	// x := 42;
	// y := double (x);

	// do we want function overloading?
	// double := (x: int) -> {return x * x;}
	// double := (x: float) -> {return x * x;}

	// templates allow you to abstract the types
	// within a function.
						// syntax from Jai
	mytemplatefunc :: (x: $T, y: T) -> {return x * y;}

	the constraint on the type is that 'x', 'y' are the same type, derived from 'T';
	implicitly, the derivation is from the type of 'x' 

	x := 3; y := 4;
	z := mytemplatefunc (x, y);

	x := 3.14; y := 5;
	z := mytemplatefunc (x, y); // is this then a syntax error?
								// the types are different, even though
								// through an implicit type conversion
								// this function call can work, and without
								// a loss of precision.

	x := 4; y := "not-an-int"
	z := mytemplatefunc (x, y); // This has to be a semantic error,
								// {int} '*' {string} 
								// is not a valid operation

	// function overloading allows you to abstract
	// the body of a function

	overloadfunc :: (x: int, y: int) -> {return x * y;}
	overloadfunc :: (x: float, y: float) -> {return x * y;}

	macros:
		a macro is not code itself, but a specification of the
		form of code. the idea being that code itself can be something
		that code can talk about. normally we talk about numbers, strings
		and other data-abstractions within code. we can also talk about control
		flow in the form of functions and conditional statements.

		c/c++ have macros, they are all handled with the preprocessor.
		 This means that they operate only with textual substitution.
		 this is okay for simple forms of macros, but lacks typechecking
		 and much of the power of lisp macros.

		 c++ has recently developed something with close to the same power 
		 as a true macro, and it is in the form of templates. in their original
		 conception templates are a way to abstract the type of a procedure.
		 this is because many algorithms work regardless of the
		 type that they consume. Linked lists, Arrays, Heaps, etc.
		 in other words, there is a -pattern- to the code, and the storage 
		 structure has the same form no matter the contents. The form of the 
		 storage medium is the pattern which is captured within the template.

		 now, with more complex structures the constraints that are placed on
		 what a


	// Helper functions
	(defun primep (number)
	  (when (> number 1)
	    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

	(defun next-prime (number)
	  (loop for n from number when (primep n) return n))

	// what we want the call to look like
	(do-primes (p 0 19)
	  (format t "~d " p))

	// semantically equivalent hand-rolled version
	(do ((p (next-prime 0) (next-prime (1+ p))))
	    ((> p 19))
	  (format t "~d " p))

	// an example macro definition
	(defmacro do-primes (var-and-range &rest body)
	  (let ((var (first var-and-range))
	        (start (second var-and-range))
	        (end (third var-and-range)))
	    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
	         ((> ,var ,end))
	       ,@body)))

	// equivalent macro form, with more explicit parameters
	(defmacro do-primes ((var start end) &body body)
	  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
	       ((> ,var ,end))
	     ,@body))



	// ad-hoc polymorphism
		adhoc :: (x: int) -> {return x * x;}
		adhoc :: (x: float) -> {return x / x;}

	// template polymorphism
		temp :: (x: $T) -> {return x * x;}

	// macro macr :: (x: $T, y: op) -> {return x y x;}

	// macro macr :: (x: {type}, {binop}) -> {return x {binop} x;}

	// macro macr :: (x: {type}, y: {lambda}, z: {static-int}) -> (list: []{type}) {
	//	l: []{type};
	//	for(i := 0; i < value; i += 1) l.prepend((y, x));
	//	return copy(l);
	//}

	// 'for' '('{declarations} ';' {conditional} ';' {post-statements}')' {statements}
	//		-> { 
	//			{declarations} 
	//			while ({conditional}) {
	//				{statements}
	//				{post-statements}
	//			}

	// 'while' '(' {expression} ')' {statements}
	//		-> {
	//				w: if ({expression}) {
	//					{statements}
	//					goto w;
	//				}
	//			}
	
	// 'if' '(' {expression} ')' {statements} 
	//		-> {
	//				jump-if-not-equal i, {expression}, {true-value},
	//				{statements}
	//				i:
	//			}



	// {constrained-block} -> {evaluate-to-bool}
	//						| {iterable}
	//						| {statement}
	//						| {declaration}
	//						| {operator}
	//						| {operator-assignment}
	//						| {operator-logical}
	//						| {operator-arithmetic}
	//						| {operator-bitwise}

///

%% ~Thoughts on things

%% Goals
// v1 goals : the static language
- functions
- conditionals and loops
- variables with primitive types
- operations

// v2 goals : the dynamic language
- pointers
- composite types
- allocators, these will be registered in the context block

// v3 goals : high level programming constructs
- polymorphism
- macros (programmer ast manipulation)
- concurrency

%%

// research
- processor primitives
-- compare-and-swap, atomic load/store, atomic rmw

