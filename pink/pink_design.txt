
%% Zen

pink is a language whose job is to allow programmers to easily
	manipulate assembly instructions as logical units and to 
	easily manipulate data around the machine efficiently.

- a small yet expressive language, built for readability, ergonomics
- and easy parsing.

- logical consistency, one obvious way of doing things,
- easy to say what is easy to do.

- The goal is also not to create a 'pure' language, nor is the language
	'impure', this language is a collection of the most sensible features
	working together to express programming ideas ergonomically. The goal 
	is to have a clear (read: unambiguous), 
	concise(read: just enough characters to communicate, but not so many
	 that it becomes a chore to write and mentally parse. see: c++ templates),
	 and highly expressive language; 

- Dimensions of the language
	- Expressivity
		the language should enable programmers solve their problems, rather
		than solve the riddle of how to express what they want to say in the
		language.

		Programmers fluent in the language should be able to easily read what
		one another are saying and doing in their code. 
		common abstractions should have a common form
		common tasks should have a common form
		it should be easy to say what is easy to do 

	- Security
		The language doesn't exist in a vacuum, a robust, expressive language
		should be aware of the security concerns of a modern language. C is 
		exploitable because it is hard to write hardened code, and easy to 
		exploit interoperations between disperate programs. More complex languages
		are exploitable because their own operation is hard to understand.

	- Performance
		writing code that utilizes its resources effectively is difficult. writing
		interoperating abstractions that can utilize shared resources is difficult.
		performance modeling should be easy to do, and require minimal cognitive
		overhead. the shape of performance modeling is uniform in the time axis, 
		and on the space axis.

	- Maintainability
		Code that is written today, may be talking to code that is written 20
		years from now. This is not something that can be ignored. How does this
		affect the other dimensions, and how does the language assist programmers
		in this dimension.

	- Testing
		testing is a non-trivial aspect of development, that also has a uniform
		shape. How does this language assist programmers in testing their own code?
		in testing unknown code? 

- Cognitive Dimensions of Abstraction

Abstraction gradient 
    What are the minimum and maximum levels of abstraction exposed by the notation? 
	Can details be encapsulated?

Closeness of mapping 
    How closely does the notation correspond to the problem world?

Consistency 
    After part of the notation has been learned, how much of the rest can be 
	successfully guessed?

Diffuseness / terseness 
    How many symbols or how much space does the notation require to produce a 
	certain result or express a meaning?

Error-proneness 
    To what extent does the notation influence the likelihood of the user making 
	a mistake?

Hard mental operations 
    How much hard mental processing lies at the notational level, rather than at
	the semantic level? Are there places where the user needs to resort to fingers 
	or penciled annotation to keep track of what’s happening?

Hidden dependencies 
    Are dependencies between entities in the notation visible or hidden? Is every
	dependency indicated in both directions? Does a change in one area of the 
	notation lead to unexpected consequences?

Juxtaposability 
    Can different parts of the notation be compared side-by-side at the same time?

Premature commitment 
    Are there strong constraints on the order in which the user must complete 
	the tasks to use the system?

    Are there decisions that must be made before all the necessary information
	is available? Can those decisions be reversed or corrected later?

Progressive evaluation 
    How easy is it to evaluate and obtain feedback on an incomplete solution?

Role-expressiveness 
    How obvious is the role of each component of the notation in the solution as a 
	whole?

Secondary notation and escape from formalism 
    Can the notation carry extra information by means not related to syntax, such 
	as layout, color, or other cues?

Viscosity
    Are there any inherent barriers to change in the notation? How much effort 
	is required to make a change to a program expressed in the notation?

    This dimension can be further classified into the following types:

        'Knock-on viscosity' : a change in the code violates internal constraints
			in the program, whose resolution may violate further internal constraints.

        'Repetition viscosity' : a single action within the user’s conceptual 
			model requires many, repetitive device actions.

        'Scope viscosity' : a change in the size of the input data set requires 
			changes to the program structure itself.

Visibility 
    How readily can required parts of the notation be identified, 
	accessed and made visible?

creative ambiguity 
	does the notation encourage interpreting several meanings of 
	the same element?

indexing 
	are there elements to guide finding a specific part?

synopsis 
	"gestalt view" of the whole annotated structure

unevenness 
	some creation paths are easier than others, 
	which bias the expressed ideas in a developed artifact.

- "Stop telling me what you are saying and just say it!"

- "If you liked the code you should have put a test around it."

- "Don't bring up performance as a talking point unless you have the
	data to back up the claim."

%% ~Zen

A program in pink is composed of declarations and statements
	Declarations:
		A declaration adds a new item to the current scope.
		This applies to
			function declarations
			variables
			unstructured scopes ( aka the unnamed scope { // } )

	Statements:
		A statement is something that has a side effect, either upon the state of a variable
			or the state of the program flow
		This applies to
			function calls
			operators (=, +, -, etc.)
			structured scopes (conditionals & loops)

Why make a new programming language?
	for fun?
	for profit?
	how about:
		There is a ton of unneccessary complexity in modern day languages
		c is in its verbosity (This is a result of being a small lang, 
			which is addmittedly a plus), pitfalls, and age.
		c++ fails in its verbosity (partly inherited, mostly added), 
			semantic overhead, and its plethora of features
		Dynamicly Typed and Garbage Collected languages fail
			in the computational overhead of garbage collection,
			the mental overhead of duck typing
			and the complexity of the languages implementation.
			if an advanced user wants to get in and tinker, they in theory can,
			but its always far more complex a design than should be required.

If these are the problems, then how is this language a solution?
	what are the design goals of pink?
		1) The language should have a small, focused feature set which can be learned
			quickly, and mastered slowly. Each feature should hold its own weight in the
			design space of the language. There shouldn't be 12 innate ways of doing one thing,
			the programming language should have a convienient built-in, with the ability for the 
			programmer to specialize should they have a unique set of constraints.

		2) The syntax of the language should make it easy to say what is easy to do.
			Taking a page out of the python school of thought, the language should be designed for
			_humans_ and not the computer. The syntax should help the programmer to understand what is happening
			not obfuscate even the simplest of ideas (looking at you c++ templates)

		3) The syntax and the semantics of the language should help the programmer build
			the necessary abstractions for small and large programs in a way that is 
			computationally effecient for the machine, and cognitively efficient for the programmer.

		4) The language should help you with the hardest of problems! 
		~Multithreading & Parrellelism.
			This is something that will be built into the language, and will have low-level and high-level
			abstractions, plus the plumbing required to get between. 
		~Dynamic Memory management~.
			This is a major sticking point of the language, C did it 80% correctly, but the 20% they didn't do
			bit new programmers so much they wanted to do away with the problem entirely. hence, Garbage Collection.
			This is too much of a perfomance hit to be acceptable. We can build better, We deserve better.
		~Hardware interface~
			What major language gives you an easy way to inject native assembly into your program?
			c, c++, do have ways of interfacing. However asm("") is clumsy for multiline statements,
			and for things like timing delays. What about nice interfaces around
			hardware devices like SPI, or USB? this is basically non-existant. C and Linux are the
			best about this. otherwise its up to the hardware vendor.
		~Interlanguage Interface~
			Should be able to talk to C, and then because everything talks with C
			we can then interface with other languages.


%% Thoughts on things
-- logical consistency : a function declaration should always look
	like a function declaration, a struct definition should always
	look like a struct declaration, a variable should have the 
	constraints that you tell it to have, this should permeate the
	design of the language. (instead of '~' and '!' we have '!' and '!!',
	because this lines up with the operator consistency of '&' and '&&',
	'|' and '||', and '^' and '^^' ((also yes, this does change '!=' to
	'!!=')))

-- this logical consistency lowers the learning curve, because there
	are less caveats to remember. This lessens cognitive burden and
	allows programmers to think about their problem, rather then how 
	to speak the language. the small feature set should make lisp 
	stype macros easier to do. Lisp style
	macros in an imperitive language is a design space that I
	would like to explore. Additional space includes state machine 
	encoding, and to self modifying code. 

-- Type Constructors
	<type-name> '(' <argument-list> ')'

	type construction seems like a necessary language feature.
	c doesn't have this, and so requires seperate intitialization
	functions for more complex types. and in my opinion this makes
	for an awkward interface. 

	var : my_struct;
	init_my_struct(var, ...);

	-vs-

	var := my_struct(...);
	

	This separation of the type
	from it's intializer creates cognitive overhead. If types
	always have a constructor it reduces the cognitive overhead
	of ensuring that types are valid after declaring them.
	dynamic memory allocation should not occur by default. 
	The default constructor should allocate
	space on the stack frame of the current function. just like
	c, the semantic rules around static variables should remain 
	largely consistent with c. while the dynamic memory assumptions
	will change somewhat.
	

-- initializer lists for structs
-- declared constructors like jai 

-- struct a :: {b: int, c: string}

	v1 : a{someint, somestring};
	v2 : a(someint, somestring);
	v3 := alloc (a, someint, somestring);
	v4 : a;
	v4 = alloc (a, someint, somestring);

	new/delete vs alloc/dealloc vs ??

	var := #alloc <type-name> <argument-list>;
	


-- a function call is so far the only syntactic construct that looks 
	like : <identifier> '(' <argument-list> ')' ';'
	if type construction calls a function, then the semantic difference
	between <function-name> '(' <argument-list> ')' ';'
	and     <type-name>     '(' <argument-list> ')' ';'
	might not be a problem.
		aside: This also seems like part of an argument for overloading
				functions as a basic feature.
	a function is always 'stored' in a variable, but we don't always
	want programmers to change top level functions, this is solved in
	two ways, first the 'fn' declarator. so you can say

	fn f (arg: int) -> {return arg * arg;}

	and second, constant binding to a variable

	var :: (arg: int) -> {return arg * arg;};

	note: declarations always have an ending ';'
			whereas the function definition, much like
			the struct, union, and enum do not have an
			ending ';'. 

-- defining and calling functions

	fn func :: (a: int, b: int) -> (int) {return a + b;}

	fn apply :: (a: [] int, b: int, f: (int, int) -> (int)) {
		for a { 
			it = f(it, b);
		}
	}

	fn apply :: (a: [] float, b: [] float, f: (float, float) -> (float)) {
		for a {
			it = f(it, b[it.index]);
		}
	}

	

-- constness is always indicated through the '::' operator.
	constant functions:
		fun :: (a: int, b: int) -> {return a + b;}

	non-const functions:
		fun := (a: int, b: [] int) -> {return for i in b {c += a + i}}

	constant type definitions
		struct my_type :: { v: int; w: float; }

	constants in code
		my_constant :: "this string is constant";
		mY_other_constant :: 42;


	/// does variable capture help? or does it conflict
	    with internalized scoping rules too much?
	
	h :: () ->
	{
		variable := "smelly";
		{
			variable := "hello"; // there is no variable shadowing
			print(variable); // prints "hello"
		}
		print(variable);     // prints "smelly"

		{
			variable = "goodbye"; // error: variable is not declared in current scope
		}

		[variable]{ // here we capture the refrence to the outer variable
			variable := "code"; // reassign the contents of variable
			print(variable);    // prints "code"
		}
		print(variable); // prints "code"
	}

	// what does polymorphism look like?
	// double := (x: $T) -> {return T * T;}
	// x := 42;
	// y := double (x);

	// do we want function overloading?
	// double := (x: int) -> {return x * x;}
	// double := (x: float) -> {return x * x;}

	// templates allow you to abstract the types
	// within a function.
						// syntax from Jai
	mytemplatefunc :: (x: $T, y: T) -> {return x * y;}

	the constraint on the type is that 'x', 'y' are the same type, derived from 'T';
	implicitly, the derivation is from the type of 'x' 

	x := 3; y := 4;
	z := mytemplatefunc (x, y);

	x := 3.14; y := 5;
	z := mytemplatefunc (x, y); // is this then a syntax error?
								// the types are different, even though
								// through an implicit type conversion
								// this function call can work, and without
								// a loss of precision.

	x := 4; y := "not-an-int"
	z := mytemplatefunc (x, y); // This has to be a semantic error,
								// {int} '*' {string} 
								// is not a valid operation

	// function overloading allows you to abstract
	// the body of a function

	overloadfunc :: (x: int, y: int) -> {return x * y;}
	overloadfunc :: (x: float, y: float) -> {return x * y;}

	macros:
		a macro is not code itself, but a specification of the
		form of code. the idea being that code itself can be something
		that code can talk about. normally we talk about numbers, strings
		and other data-abstractions within code. we can also talk about control
		flow in the form of functions and conditional statements.

		c/c++ have macros, they are all handled with the preprocessor.
		 This means that they operate only with textual substitution.
		 this is okay for simple forms of macros, but lacks typechecking
		 and much of the power of lisp macros.

		 c++ has recently developed something with close to the same power 
		 as a true macro, and it is in the form of templates. in their original
		 conception templates are a way to abstract the type of a procedure.
		 this is because many algorithms work regardless of the
		 type that they consume. Linked lists, Arrays, Heaps, etc.
		 in other words, there is a -pattern- to the code, and the storage 
		 structure has the same form no matter the contents. The form of the 
		 storage medium is the pattern which is captured within the template.

		 now, with more complex structures the constraints that are placed on
		 what a


	// Helper functions
	(defun primep (number)
	  (when (> number 1)
	    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))

	(defun next-prime (number)
	  (loop for n from number when (primep n) return n))

	// what we want the call to look like
	(do-primes (p 0 19)
	  (format t "~d " p))

	// semantically equivalent hand-rolled version
	(do ((p (next-prime 0) (next-prime (1+ p))))
	    ((> p 19))
	  (format t "~d " p))

	// an example macro definition
	(defmacro do-primes (var-and-range &rest body)
	  (let ((var (first var-and-range))
	        (start (second var-and-range))
	        (end (third var-and-range)))
	    `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
	         ((> ,var ,end))
	       ,@body)))

	// equivalent macro form, with more explicit parameters
	(defmacro do-primes ((var start end) &body body)
	  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))
	       ((> ,var ,end))
	     ,@body))



	// ad-hoc polymorphism
		adhoc :: (x: int) -> {return x * x;}
		adhoc :: (x: float) -> {return x / x;}

	// template polymorphism
		temp :: (x: $T) -> {return x * x;}

	// macro macr :: (x: $T, y: op) -> {return x y x;}

	// macro macr :: (x: {type}, {binop}) -> {return x {binop} x;}

	// macro macr :: (x: {type}, y: {lambda}, z: {static-int}) -> (list: []{type}) {
	//	l: []{type};
	//	for(i := 0; i < value; i += 1) l.prepend((y, x));
	//	return copy(l);
	//}

	// 'for' '('{declarations} ';' {conditional} ';' {post-statements}')' {statements}
	//		-> { 
	//			{declarations} 
	//			while ({conditional}) {
	//				{statements}
	//				{post-statements}
	//			}

	// 'while' '(' {expression} ')' {statements}
	//		-> {
	//				w: if ({expression}) {
	//					{statements}
	//					goto w;
	//				}
	//			}
	
	// 'if' '(' {expression} ')' {statements} 
	//		-> {
	//				jump-if-not-equal i, {expression}, {true-value},
	//				{statements}
	//				i:
	//			}

///
/*
	A && B || C == D 	
	-> ((A && B) || C) == D)

	A || B ^^ C && D	
	-> (A || (B ^^ (C && D)))

	A && B || C ^^ D	
	-> (A && B) || (C ^^ D)

	A + B == C - D	
	-> (A + B) == (C - D)

	A + B && C & D	
	-> (A + B) && (C & D)

	A + B | D
	-> ((A + B) | D)
	
	A - B ^ C | D
	-> ((A - B) ^ C) | D)
	
	!A ^ B & C()
	-> (!A) ^ (B & (C()))
	
	!A ^ B | C()
	-> ((!A) ^ B) | (C())

	A & B < C | D
	-> (A & B) < (C | D)
	
	A & B < C ^ D | E	
	-> (A & B) < ((C ^ D) | E)

	A < B == C < D
	-> (A < B) == (C < D)

	A + B | C == D	
	-> ((A + B) | C) == D

	A == B ? C : D 
	-> (A == B) ? (C) : (D) 
*/
/*
Token := (<op1> | <op2> | .. | <opn> )
	-->
		if ( <<lookahead-predicts-op1>> ) { <<match-op1>> }
		else if ( <<lookahead-predicts-op2>> ) { <<match-op2>> }
		..
		else if ( <<lookahead-predicts-opn>> ) { <<match-opn>> }
		else <<unknown-token-error>> // no viable alternatives

	Token := (optional-opt)? (op1 | op2)
	-->
		if (<lookahead-predicts-optional-opt) { match-optional-opt }
		if (<lookahead-predicts-op1) {match-op1}
		else if (<lookahead-predicts-op2) {match-op2}
		else <unknown-token>

	Token := (one-or-more-opt)+ (op1 | op2)
	-->
		do { // ( .. )+
			<<code-matching-one-or-more-opts>>
		} while ( <<lookahead-predicts-an-alternative-of-the-one-or-more-opts>> )
		if (<lookahead-predicts-op1) {match-op1}
		else if (<lookahead-predicts-op2) {match-op2}
		else <unknown-token>

	Token := (zero-or-more-opts)* (opt1 | opt2)
	-->
		while (<<lookahead-predicts-an-alternative-of-the-zero-or-more-opts>> ) {
			<<code-matching-zero-or-more-opts>>
		}
		if (<lookahead-predicts-op1) {match-op1}
		else if (<lookahead-predicts-op2) {match-op2}
		else <unknown-token>
*/

%% ~Thoughts on things

%% Goals
// v1 goals : the static language
- functions
- conditionals and loops
- variables with primitive types
- operations

// v2 goals : the dynamic language
- pointers
- composite types
- allocators, these will be registered in the context block

// v3 goals : high level programming constructs
- polymorphism
- macros (programmer ast manipulation)
- concurrency

%%

// research
- processor primitives
-- compare-and-swap, atomic load/store, atomic rmw

