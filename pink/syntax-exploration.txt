


#construction:
	var var-0 := 0;

	var var-1 : int;

# construct an anonymous tuple using '[,]'
# (instead of the traditional parenthized list '(,)' syntax,
# because the '(,)' syntax has an ambiguous parse in expressions.  
# it's undecidable between a sub-expression and a tuple 
# in an LL(1) restricted grammer.

	return [1, "hello"];

#abstraction:

	adt type-name = A type-1 + type-2 | B type-1 + type-3;

	fn fun-1 (arg1 : int, arg2 : int) -> bool {
		return arg1 == arg2;
	}


# with polymorphic constructors for our algebraic data types,
# (sum and product, in c respectively: struct and union)

	adt Maybe = None: Nil | Some: $SomeType

# with the associated constructors
	
	Maybe(Nil) -> Maybe(None)

	Maybe(j: $SomeType) -> Maybe(SomeType)

# then we could imagine a function that returns a maybe

	allocate(type: $SomeType) -> Maybe(Ptr(SomeType))

# one might observe this and say "well hey, all you've done
# is moved the problem of the nullptr into the type system,
# doesn't that just move the problem and not actually solve it?"
# my respose would be: well, the static analysis tools of the
# compiler can all queue into the type of something easily,
# so it turns pointer validity from a user managed issue,
# to something that the language can build semantics around.
# it also formalizes one way of handling uninitialized memory,
# and makes it unambiguous to use.

# if we consider something that is analagous to the void*
# the 'any' type, it is like the 'Maybe' type in that it encapsulates
# any type, but unlike the 'Maybe' type, the 'any' type isn't all that
# useful. why not you ask? well consider why we have types in the
# first place. to encapsulate behavior. when we know the type
# of a variable, we also know what the valid operations on that type are.
# if you have a container that holds anything, then what behavior can
# you rely on? none. 
# there is by definition no behavior that is valid on all.
# possible types. there are aspects of a type that are universal,
# such as the name, and the size. but behavior of the type is not something that
# all types share. however, some types do share behavior. for instance we 
# can consider the case of addition. addition makes sense when talking about
# a variety of abstractions, Integers, Real numbers, Vectors, Matricies, and more.
# but in each case, the method of addition is different. in this instance
# function overloading serves us nicely, we are able to define an operation
# called addition, and define an operator '+', and we can define
# a new function with the same name, but different parameter types and
# then through type analysis of occurances of add or '+' in the source text,
# we can correctly call each different addition function depending on the
# type of the argument. this is both intuitive and expressive.
# it gives programmers a very natural way of talking about types to rely
# on overloading, and it can improve legibility in some places.

# what if i was in different circumstances, and I was instead writing 
# a generic function which would take a less specific type?
# instead of taking an argument of a specific type, it was able to
# take arguments with types that garunteed certain semantics were valid
# upon said type. we could invoke certain constraints on the passed types
# and if they hold, we can consider the function call to be valid.
# a constraint tests some aspect of the type, therefore if
# the constraint passes the type could be said to 'posses' or 'have'
# that aspect. 

# given the previous information, we could formulate:
# I have a function which makes sense only on types which
# can be added together. (this functions operation relies upon calling
# the add function on two variables with said type)
# this semi-opaque type would not actually care what the name of
# any given type passed was, it would only care that the function
# add(a: type-name, b: type-name) -> type-name was defined in the
# current context.
# if you consider this carefully you might say that this is
# semantically equivalent to having a virtual base-class between
# all types which have add supported. which is true to a point.
# the main differences are that the constraints can be any valid pink
# statement, and are not only limited to simple does this function exist.
# and that one does not have to modify the underlying type
# to define new constraints around the type.

# what does the syntax of a function taking a type aspect look like?

the keyword aspect then always defines a function with this signature
fn-name(t: $TypeName) -> bool 

aspect Addable (t: $Type) -> bool { 
	return Exists(t + t);
}

then we could define a function which looked like
fn convoluted-double(x: Addable) -> {
	return x + x;
}

and that would be a valid function to double any type which supported
addition semantically.

# if we consider that dynamic memory is always handled in an option type,
# it also changes the syntax around accessing dynamic memory thusly
#{
	a common pattern in C surrounding dynamic memory looks like
	
	var* my-var-ptr = (var*)malloc(sizeof(var));
	if(my-var-ptr != nullptr) {x}
	else {y}

	which means:
	allocate memory of this size, and this type
	and if you did allocate do x,
	if you couldn't allocate enough do y.

	well with the Maybe type and an allocate function
	written in a polymorphic and reflective way like {
		
		adt Maybe = None: Nil | Some: $SomeType
		
		Maybe(Nil) -> Nil

		Maybe(j: $SomeType) -> SomeType

		allocate(type: $SomeType) -> Maybe(Pointer(SomeType))
		# polymorphic because the type is deduced from the 
		# passed argument, Reflective because allocate needs
		# to know the size of the type, which relies on 
		# knowledge of the hardware.
	}

	we could imagine a syntax like {
		my-dynamic-var := allocate(my-type);
		if (my-dynamic-var) {x}
		else {y}
	}
	and it would have the same meaning as the C statements above
	with one difference, being that my-dynamic-var has the type
	Maybe(Pointer(SomeType())) not Pointer(SomeType())
	and the if conditional would know that by default when handed
	an option type, it uses the None/Nil option as the else case.
	while loops could have the same default. 

#}

# first class functions. c already has function pointers,
# what if we just extend function pointer semantics and change the
# syntax such that we can make functions first-class
# so maybe the function type could be ->?

# in a function definition:

fn first-class(p: int, p: int, fun(int, int) -> int) -> int {}

# we could imagine a definition of what could be a function argument
# in a function definition to include this lambda syntax
