


fn double :: (i : int) -> {
	a = 2, b = 45, c = 64;

	return i * i;
}

fn factorial :: (n : int) -> {
	if (n == 1 | n == 0) {
		return 1;
	} else {
		return n * factorial(n - 1);
	}
}

fn doubledouble :: (i: int, j: int) -> (int, int) {
	return i * i, j * j;
}

expr := (A + B) * C / (D == E) || F;

lamb := (x: int, y: int) -> (int, int) { };

lamb_hard := (max: (a: int, b: int) -> (bool), a: int, b: int) -> (int) {};

expr1 := A() * B() + -C;

expr2 := A(B, C)[D + E * F].G * *I == J; 

a := 12;
b := 1.5;
c := "Hello, World!";
d := true;
e := false;
f := user_type;
g : int;
h : float;
i : text;
j : bool;
k :: 42;
l :: 105.40;
m :: "Constant: Hello, World!";
n :: true;
o :: false;
p : int = 108;
q : float = 420.69;
r : text = "Type Annotated Dynamic Assign: Hello, World!";
s : bool = true;
t : bool = false;

fn func :: (a: int, b: int) -> (int) {}
fn fnuc :: (c: float, d: float) -> {}
fn hell :: (e: string, f: string) -> {}
fn rgrd :: (g: bool, h: bool) -> (string) {}

fn hard :: (first: (a: int, b: int) -> (int), second: int) -> (int) { }
