

expr := (A + B) * C / (D == E) || F;

lamb := (x: int, y: int) -> (int, int) { };

lamb_hard := (max: (a: int, b: int) -> (bool), a: int, b: int) -> (int) {};

expr1 := A() * B() + -C;

expr2 := A(B, C)[D + E * F - G].H * *I == J; 

a := 12;
b := 1.5;
c := "Hello, World!";
d := true;
e := false;
f := user_type;
g : int;
h : float;
i : string;
j : bool;
k :: 42;
l :: 105.40;
m :: "Constant: Hello, World!";
n :: true;
o :: false;
p : int = 108;
q : float = 420.69;
r : string = "Type Annotated Dynamic Assign: Hello, World!";
s : bool = true;
t : bool = false;

fn func :: (a: int, b: int) -> (int) {}
fn fnuc :: (c: float, d: float) -> {}
fn hell :: (e: string, f: string) -> {}
fn rgrd :: (g: bool, h: bool) -> (string) {}

fn hard :: (first: (a: int, b: int) -> (int), second: int) -> (int) { }
