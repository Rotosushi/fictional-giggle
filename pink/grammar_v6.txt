
<module> := (<module-level-declaration>)* EOF

<module-level-declaration> := <type-definition>
							| <declaration>

<type-definition> := 'fn' <identifier> '::' <lambda-definition>
				   | 'struct' <identifier> '::' <struct-block>

		// TODO:   | ('struct' | 'union') <identifier> '::' <composite-type-block>
		// TODO:   | 'enum' <identifier> '::' <enumeration-block>
		// TODO:   | 'alias' '(' <identifier> ',' <type-specifier> ')'
		// TODO:   | <macro>
		// TODO:   | <thread>
		// TODO:   | <tuple>

<struct-block> := '{' (<identifier> ':' <type-specifier> ';')* '}'

// tuples are unnamed structs, but instead of declaring a new type that can be initialized
// they hold local variables, or new variables.
<tuple-block> := '{' ( (<identifier> | <type-specifier>) ';')* '}'
 
<declaration>  := <identifier> ':' <type-specifier> ('=' <initializer>)? ';'
				| <identifier> ('::' | ':=') <initializer> ';'

<initializer>  := <lambda-definition>
				| <literal>
				| <identifier>
				| <expr>

<type-specifier> := <lambda-header>
				  | <type-primitive>
				  | <identifier>
				  | <array-type>
				  | <composite-type-block>

// <expr> has to resolve to something that can be used to count with
<array-type> := '[' <expr> ']' <type-specifier>

<lambda-definition> := <lambda-header> <lambda-body> 

<lambda-header> := <argument-list> '->' (<return-list>)?
<lambda-body> := <block>
<block> := '{' (<declaration> | <statement>)* '}'

<composite-type-block> := '{' (<declaration>)* '}'

<argument-list> := '(' (<arg> (',' <arg>)*)? ')'

<arg> := <identifier> (':' <type-specifier>)?
	   | <expression>

<return-list> :=  '(' <type-specifier> (',' <type-specifier>)*')'

<statement> := <expression>
			 | <conditional>
			 | <iteration>
			 | <block>


<expression> := (<expr>)? ';'

<expr> := <assignment-expr>

<assignment-expr> := <logical-exuality-expr>
				   | <unary-expr> <assignment-operator> <assignment-expr>

<logical-equality-expr> := <logical-relation-expr>
						 | <logical-equality-expr> '==' <logical-relation-expr>
						 | <logical-equality-expr> '!=' <logical-relation-expr>

<logical-relation-expr> := <logical-or-expr>
						 | <logical-relation-expr> '<' <logical-or-expr>
						 | <logical-relation-expr> '>' <logical-or-expr>
						 | <logical-relation-expr> '<=' <logical-or-expr>
						 | <logical-relation-expr> '>=' <logical-or-expr>

<logical-or-expr := <logical-xor-expr>
				  | <logical-or-expr> '|' <logical-xor-expr>

<logical-xor-expr> := <logical-and-expr>
					| <logical-xor-expr> '^' <logical-and-expr>

<logical-and-expr> := <logical-not-expr>
					| <logical-and-expr> '&' <bitwise-or-expr>

<bitwise-or-expr>  := <bitwise-xor-expr>
					| <bitwise-or-expr> '||' <bitwise-xor-expr>

<bitwise-xor-expr> := <bitwise-and-expr>
					| <bitwise-xor-expr> '^^' <bitwise-end-expr>

<bitwise-and-expr> := <bitwise-not-expr>
					| <bitwise-and-expr> '&&' <bitwise-shift-expr>

<bitwise-shift-expr> := <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '<<' <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '>>' <arithmetic-additive-expr>

<arithmetic-additive-expr> := <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '+' <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '-' <arithmetic-multiplicative-expr>

<arithmetic-multiplicative-expr> := <typecast-expr>
								  | <arithmetic-multiplicative-expr> '*' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '/' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '%' <postfix-expr>

<postfix-expr> := <primary-expr>
				| <postfix-expr> '[' <expression> ']'
				| <postfix-expr> <argument-list>
				| <postfix-expr> '.' <identifier>

<primary-expr> := <identifier>
				| <literal>
				| '(' (<expr>)? ')'

<literal>  := <numeric-literal>
			| <string-literal>

<assignment-operator> :=  '='
						| '*='
						| '/='
						| '%='
						| '+='
						| '-='
						| '<='
						| '>='
						| '&='
						| '^='
						| '|='

<unary-operator> := '!'
				  | '!!'
				  | '+'
				  | '-'

<type-primitive> := 'int'
				  | 'float'
				  | 'text'
				  | 'bool'


<identifier> := [a-zA-Z]([(- | _)a-zA-Z0-9])*

<numeric-literal>  := <numeric-literal-decimal>
					| <numeric-literal-hexidecimal>
					| <numeric-literal-octal>
					| <numeric-literal-binary>

<numeric-literal-decimal>	  := [0-9']*(.)?[0-9']+
<numeric-literal-hexidecimal> := ('0h' | '0H')[0-9a-fA-F']+
<numeric-literal-octal>		  := ('0o' | '0O')[0-7']+
<numeric-literal-binary>	  := ('0b' | '0B')[0-1']+