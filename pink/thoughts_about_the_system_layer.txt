

so, what is the system layer and why does it exist?

well, to me, the systems layer is the next layer up from
the hardware. it is the layer of semantics which supports
the layer above. 'Higher' level languages, and 'higher' level
code is difficult to define, as the notion of what is 'high' 
level has changed since the days when you had to code in assembly.

so, really the term makes no sense because the semantics of
a language depend more on which semantics they adopt then
some arbitrary 'height'.

a more realistic difference would be
in the constraints that are placed on the
programs which are written in the language.

this difference is easy to spot if we consider
the differences between C and LISP.
In C (1972) the language is treated more as a very nice
assembler, with it's abstractions chosen carefully to
have minimal overhead, but with a lot of semantic versatility.

In LISP (1960) the langauge does not run on any native harware,
(...now-a-days, in the past there have been so-called LISP machines.)
code is interpreted by an abstract machine, which then
can act as if it was the program specified by the source code.
and the source code that one looks at is wildly different
in syntax and semantics from a traditional assembly language.

in LISP there is no conception of how exactly we mean to accomplish
any given task, but we assume the machine knows how to execute it's language,
and by this assumption programmers can write general use programs.
the language is therefore declarative.

in C you specify how the machine is going to accomplish the task.
the language is therefore imperitive.


so, from a certain perspective, all general purpose languages are
interchangable with each other, they are all "turing-complete".
which means that, however awkwardly, any conceivable algorithm could
be specified in the language. 

what then is the point of ever making a new language?

well, the language we use has a profound effect on the ideas we have
and the way we think. it also affects the way we recombine and reevaluate ideas.
subtle changes in syntax can have a profound effect on the underlying semantics.
to the point that a single misplaced character can result in any number of errors in
any stage of the life of the compilation or the runtime of the resulting program.
(depending entirely on which character gets misplaced and where, of course.)
all this to say that programming is very hard, and it would be nice if we had
a language in which it was easy to say what is easy to do. or even nicer, a language
in which it was easy to say what is hard to do. to paraphrase Donald Knuth, a program
should be written so that it is easy for another human to tell what it is the computer
should be doing.



