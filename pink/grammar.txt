/*
// there are three levels of scope in pink, global, file, and local
// global names are always visible from anywhere in the program
// file names are only visible in the file in which they are declared
// local names are only visible in the scope in which they are declared


$ single line comment

// declares default initialized variable of type type-name
variable-name : type-name ;

x : int;
x : float;
x : text;
x : bool;
x : user-type;

// declares initialized variable of type type-name
variable-name : type-name = initializer ;

x : int = 0;
x : float = 0.0;
x : text = "Hello, World!";
x : bool = true;
x : user-type = initializer;

// declares initialized constant of type deduced from initializer
variable-name :: initializer ;

x :: 0; $ type : int
x :: 0.0; $ type : float
x :: "Constant String"; $ type : text
x :: true; $ type : bool

// declares initialized variable of type deduced from initializer
variable-name := initializer ;

x := 0;
x := 0.0;
x := "Variable String";
x := false;

// declares a function
fn function-name :: (arg1 : arg-type, arg2 : arg-type) -> (return-type) {
	variable : type-name;
	if (variable == some-value) {
		return expression;
	} else if (variable == some-other-value) {
		return expression;
	} else {
		return expression;
	}
}

// functions can be called
// variable type is deduced from return type of function.
variable := function-name(a0, a1);

// return type is optional, and deduced from return statements
fn function-name :: (arg : arg-type) -> {
	while (arg == some-value) {
		func(arg);
	}
	return expression;
}

// you can define lambdas
// a lambda exists only in the current scope
// simply, it is a variable that can be called. the lambda is only
// visible from the scope it is declared in.
lambda-var := (arg1 : int) -> { return arg1 *= 2; };

val = lambda-var(2);

// lambda's/function's as args
fn meta-func :: (comp-func : (a : type1, b: type2) -> (bool), val1 : type1, val2 : type2) -> (bool) {
	return comp-func(val1, val2);
}

// in order to call 'meta-func' the first argument must be a symbol which
// can be called and has the correct signature. you could declare a fn
// with the signature:
fn comp-fn :: (x : type1, y : type2) -> {
	return x == y;
}

// then...
arg1 : type1;
arg2 : type2;

result = meta-fn(comp-fn, arg1, arg2);

// ..or you could inline with a lambda
result = meta-fn((a : type1, b : type2) -> (bool) { return a == b; }, arg1, arg2);


// arrays can be declared with []
// arrays are a homogenous composite type
array : [10] int;
array : [] int = { 0, 1, 2, 3 };
array : [4] int = { 0, 1, 2, 3 };

// arrays can be accessed with the [] operator
value = array[0];
value = array[1]; 
// etc.

// declare a new composite type with type-name = "struct-name"
struct struct-name :: {
	member1 : member-type;
	member2 : member-type;
}

// declare new variables of that type
// initialized from a tuple, the types must match in number and order

var : struct-name = { value-of-type-member-type, value-of-type-member-type };

// struct member access
var.member1;
var.member2;

// a tuple is basically an unnamed struct, alternatively
// it could be considered as a heterogenious array
// it differs in that it does not define a new type-name
// and doesn't have named fields. it's members are accessed via
// the [] operator. 
// each member of the tuple must be specified with its type,
// either deduced and copied from a local variable, or
// default constructed.
tuple := { value1, value2, value3, value4 };
tuple[0] // value1
tuple[1] // value2
// etc.

// functions can have multiple returns
// the multiple return values are passed as a tuple
fn neat-func (arg0 : int, arg1 : float) -> (int, float) {
	return arg0 + arg0, arg1 + arg1;
}

// neat-var is a tuple-type now
neat-var := neat-func(1, 2);
neat-var[0]; // 2
neat-var[1]; // 4

// tuples can be unpacked into multiple variables
neater_var1, neater_var2 = neat-func(1, 2);
neater_var1; // 2
neater_var2; // 4

// '_' NOT IMPLEMENTED IN V1, for now
// tuple unpacking must be explicit!!
// you can ignore values you don't want with _
neatest, _ = neat-func(1, 2);
neatest; // 2

_, neatester = neat-func(1, 2);
neatester; // 4

fn three-return :: (arg1 : int, arg2 : int, arg3 : int) -> {
	return arg1 *= 2, arg2 *= 2, arg3 *= 2;
}

first, second, third = three-return(1, 2, 3);
first; // 2
second; // 4
third; // 6

// positional assignment from the tuple
// first gets tuple[0], underscore says ignore the rest
first, _ = three-return(1, 2, 3);

// positional assignment, first = 2, third = 6
// _ says ignore all but the first and last values
first, _, third = three-return(1, 2, 3);

// ignore all but the last value
_, third = three-return(1, 2, 3);

*/

// basics:

// programs are composed of
// constants, variables, and functions

// constants can have primitive or composite types
// variables can have primitive or composite types

// functions have a type via argument list and return list.
//	they are called by name

// when a variable has a type, all operations legal on that type
// are legal on that variable

// a program is defined by 'modules'. each file defines a single module.
// all modules exist in global space and can 'see' eachother, but
// only the export list of each module is visible to others.

// file level scope
// module grammar
<module> := (<module-declaration>)* EOF

<module-declaration> := <module-definition>
					  | <function-definition>
					  | <struct-definition>
					  | <variable-declaration>

<module-definition> := 'module' '::' <module-definition-block>

<module-definition-block> := '{' (<module-keyword-expression>)* '}'

<module-keyword-expression> := 'import' <id> (',' <id>)* ';'
							 | 'export' <id> (',' <id>)* ';'
							 | 'begin' <id> ';'

// function grammar
<function-definition> := 'fn' <identifier> '::' <lambda-definition>

<lambda-definition>   := <lambda-header> <lambda-body>

<lambda-header>   := <argument-list> '->' (<return-list>)?
<lambda-body>     := <block> 

<argument-list>   := '(' (<arg> (',' <arg>)*)? ')'
<arg>             := <identifer> ':' <type-specifier>

<return-list>     := '(' (<type-specifier> (',' <type-specifier>)*)? ')'

<lambda-type> := <argument-list> '->' <return-list>

<block> := '{' (<variable-declaration> | <statement>)* '}'

// composite types grammar
<struct-definition>  := 'struct' <identifier> '::' <struct-block>

<struct-block>		 := '{' (<member-declaration>)* '}'

<member-declaration> := <id> ':' <type-specifier> ';'

<tuple> := '{' <initializer> (',' <initializer>)* '}'

<type-tuple> := '{' <type-specifier> (',' <type-specifier>)* '}'

<array-type> := '[' (<expr>)? ']' <type-specifier>

// variable grammar
<variable-definition> := <id> ':' <type-specifier> ('=' <initializer>)? ';'
					   | <id> ('::' | ':=') <initializer> ';'

<type-specifier> := <lambda-type>
				  | <type-tuple>
				  | <array-type>
				  | <primitive-type>
				  | <id>

<initializer>  := <lambda-definition>
				| <expr>

// statement grammar
<statement> := <if-condition>
			 | <while-loop>
			 | <dowhile-loop>
			 | <expression>

<if-condition> := 'if' '(' (<expr>)? ')' <statement> ('else' <statement>)?

<while-loop> := 'while' '(' (<expr>)? ')' <statement>

<dowhile-loop> := 'do' <statement> 'while' '(' (<expr>)? ')' ';'

<expression> := <expr> ';'

<expr> := <assignment-expr>
		| <expr> ',' <assignment-expr>

<assignment-expr> := <logical-exuality-expr>
				   | <unary-expr> <assignment-operator> <assignment-expr>

<logical-equality-expr> := <logical-relation-expr>
						 | <logical-equality-expr> '==' <logical-relation-expr>
						 | <logical-equality-expr> '!=' <logical-relation-expr>

<logical-relation-expr> := <logical-or-expr>
						 | <logical-relation-expr> '<' <logical-or-expr>
						 | <logical-relation-expr> '>' <logical-or-expr>
						 | <logical-relation-expr> '<=' <logical-or-expr>
						 | <logical-relation-expr> '>=' <logical-or-expr>

<logical-or-expr := <logical-xor-expr>
				  | <logical-or-expr> '|' <logical-xor-expr>

<logical-xor-expr> := <logical-and-expr>
					| <logical-xor-expr> '^' <logical-and-expr>

<logical-and-expr> := <logical-not-expr>
					| <logical-and-expr> '&' <bitwise-or-expr>

<bitwise-or-expr>  := <bitwise-xor-expr>
					| <bitwise-or-expr> '||' <bitwise-xor-expr>

<bitwise-xor-expr> := <bitwise-and-expr>
					| <bitwise-xor-expr> '^^' <bitwise-end-expr>

<bitwise-and-expr> := <bitwise-not-expr>
					| <bitwise-and-expr> '&&' <bitwise-shift-expr>

<bitwise-shift-expr> := <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '<<' <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '>>' <arithmetic-additive-expr>

<arithmetic-additive-expr> := <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '+' <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '-' <arithmetic-multiplicative-expr>

<arithmetic-multiplicative-expr> := <typecast-expr>
								  | <arithmetic-multiplicative-expr> '*' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '/' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '%' <postfix-expr>

<postfix-expr> := <primary-expr>
				| <postfix-expr> '[' <expression> ']'
				| <postfix-expr> <argument-list>
				| <postfix-expr> '.' <identifier>

<primary-expr> := <identifier>
				| <literal>
				| <tuple>
				| '(' (<expr>)? ')'


// graphemes
<id> := [a-zA-Z]((_ | -)a-zA-Z0-9)*

<literal> := <text-literal>
		   | <numeric-literal>
		   | <boolean-literal>

<text-literal> := '"' (_)* '"'

<numeric-literal>  := <numeric-literal-decimal>
// TODO:
					| <numeric-literal-hexidecimal>
					| <numeric-literal-octal>
					| <numeric-literal-binary>

<numeric-literal-decimal>	  := [0-9']*(.)?[0-9']+
// TODO:
<numeric-literal-hexidecimal> := ('0h' | '0H')[0-9a-fA-F']+
<numeric-literal-octal>		  := ('0o' | '0O')[0-7']+
<numeric-literal-binary>	  := ('0b' | '0B')[0-1']+

<boolean-literal> := 'true'
				   | 'false'

<primitive-type> := 'int'
				  | 'float'
				  | 'text'
				  | 'bool'

<unary-operator> := '!'
				  | '!!'
				  | '+'
				  | '-'
				  | '*'
				  | '&'


