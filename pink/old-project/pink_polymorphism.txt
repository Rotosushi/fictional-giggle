types are an abstraction over the raw value of a word (in this context, the 'word' of a computer will be 32/64 bits long)
	we can specify some method of bit interpretation that gives us all the primitive types
	- ordinal types (treat the word as an integer, signed or unsigned, or an enumeration)
	- real numbers (treat the word as floating point values)
	- characters (treat the word as a character, or part of some more complex character)

	we can specify composite types, this is an abstraction over collections of types
	- arrays (homogenous composite type addressed by position)
	- structures/tuples (heterogeneous composite type addressed by name, or position)
	- set/union/sum (a type that is defined by the set of types it could contain)

	polymorphism is used when the particular type matters less than a specific aspect
	shared by multiple types. such as it's size, or what operations you can preform.

	a simple case is ints and floats, both represent numbers, and numbers have the same operations defined
	to manipulate them. the 'add' operation is polymorphic with regards to these types.

	so say you want to define a new type, lets use the mathematical concept of a vector for example
	
	struct cartesian_vector :: {
		float x;
		float y;
	}

	a : {float, float}; // not a vector type, has tuple type
	b : vector = { 8, 9 }; // vector type
	c := vector(8, 9);   // vector type
	d : vector = a;

	// this defines a new function entirely
	fn add :: (vector a, vector b) {
		return vector(a.x + b.x, a.y + b.y);
	}

	//this i would like to have the effect of adding
	//vectors to the valid set of types that '+' can
	//operate on. (like how c++ works with their operator fns)
	fn operator+ :: (vector a, vector b) {
		return vector(a.x + b.x, a.y + b.y);
	}

	
	---- what about naming set's of expressions?
	what about primitive's that can be composed?
	maybe like:
	
		incrementable - something that supports '+' operations
		decrementable - something that supports '-' operations
		multiplicable - something that supports '*' operations
		divisible     - something that supports '/', '%' operations
		assignable    - something that supports '=' operations
		derefrencable - something that supports prefix '*' operations
		refrencable   - something that supports prefix '&' operation
		constructable - something that returns dynamic storage
		destructable  - something that destroys dynamic storage
		positional access - something that can be accessed by []
		named access  - something that can be accessed by .
		callable      - something that can be accessed by ()
