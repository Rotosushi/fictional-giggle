
----- Attempt 2 Pink Grammar -----
// Assuming a single input file for now

<program> := (<header>)? ((<declaration>) | (<statement>))*

<declaration> := (<variable-declaration> | <type-alias>) 

<variable-declaration> := <composite-type-declaration>
						| <identifier> <assignment-operator> <initializer>
						// TODO: <polymorphic-type-declaration>

<type-alias> := 'alias' <identifier> '::' <type-specifier>

// TODO: <header> := 

<identifier> := [a-zA-Z]([(- | _)a-zA-Z0-9])*

<numeric-literal>  := <numeric-literal-decimal>
					| <numeric-literal-hexidecimal>
					| <numeric-literal-octal>
					| <numeric-literal-binary>

<numeric-literal-decimal>	  := [0-9']*(.)?[0-9']+
<numeric-literal-hexidecimal> := ('0h' | '0H')[0-9a-fA-F']+
<numeric-literal-octal>		  := ('0o' | '0O')[0-7']+
<numeric-literal-binary>	  := ('0b' | '0B')[0-1']+


<assignment-operator> :=  '=' 
						| ':'
						| ':='
						| '::'
						| ':' <type-specifier> '='
						| '*='
						| '/='
						| '%='
						| '+='
						| '-='
						| '<<='
						| '>>='
						| '&='
						| '^='
						| '|='

<unary-operator> := '&'
				  | '*'
				  | '+'
				  | '-'
				  | '!'
				  | '!!'

<initializer>  := <lambda-type>
				| <identifier>

<type-specifier>   := <type-primitive>
					| <lambda-type>
					| <identifier>

<type-primitive>   := 'maybe'
					| 'none'
					| 'u8'
					| 'u16'
					| 'u32'
					| 'u64'
					| 's8'
					| 's16'
					| 's32'
					| 's64'
					| 'f32'
					| 'f64'
					| 'int'
					| 'float'
					| 'char'
					| 'string'
					| 'bool'

<lambda-type> := '(' <arguments> ')' ('(' '->' <return-values> ')')? <compound-statement>

<arguments> := <arg> (',' <arg>)*

<arg>		:= ((<identifier> ':')? <type-specifier>)

<return-values> := <arguments>

<compound-statement> := '{' (<declaration> | <statement>)* '}'

<composite-type-declaration> := (<identifier>)? ('struct' | 'union') '::' '{' (<declaration>)* '}'
							  | (<identifier>)? 'enum' '{' <enum-values> '}'
							  | <identifier> <assignment-operator> '[' (<constant-expression>)? ']' <type-specifier>

<statement> := <expression-statement>
			 | <compound-statement>
			 | <conditional-statement>
			 | <iteration-statement>

<conditional-statement> := 'if' '(' <expression> ')' <statement>
						 | 'if' '(' <expression> ')' <statement> 'else' <statement>
						 | // TODO: switch '(' <expression> ')' <statement>

<iteration-statement> :=  'while' '(' <expression> ')' <statement>
						| 'do' <statement> 'while' '(' <expression> ')'
						| 'for' '(' (<expression>)? ';' (<expression>)? ';' (<expression>)?')' <statement>

----- Expressions follow operator precedence ----

<expression-statement> := (expression)?

<expression> := <assignment-expression>
			  | <expression> ','  <assignment-expression>

<constant-expression> := <ternary-expression>

<assignment-expression> := <ternary-expression>
						 | <unary-expression> <assignment-operator> <assignment-expression>

<ternary-expression> := <logical-or-expression>
					  | <logical-or-expression> '?' <expression> ':' <ternary-expression>

<logical-or-expression> := <logical-xor-expression>
						 | <logical-or-expression> '||' <logical-xor-expression>

<logical-xor-expression> := <logical-and-expression>
						  | <logical-xor-expression> '^^' <logical-and-expression>

<logical-and-expression> := <bitwise-or-expression>
						  | <logical-and-expression> '&&' <bitwise-or-expression>

<bitwise-or-expression> := <bitwise-xor-expression>
						 | <bitwise-or-expression> '|' <bitwise-xor-expression>

<bitwise-xor-expression> := <bitwise-and-expression>
						  | <bitwise-xor-expression> '^' <bitwise-and-expression>

<bitwise-and-expression> := <logical-equality-expression>
						  | <bitwise-and-expression> '&' <logical-equality-expression>

<logical-equality-expression> := <logical-relation-expression>
							   | <logical-equality-expression> '==' <logical-relation-expression>
							   | <logical-equality-expression> '!!=' <logical-relation-expression>

<logical-relation-expression> := <bitwise-shift-expression>
							   | <logical-relation-expression> '<' <bitwise-shift-expression>
							   | <logical-relation-expression> '>' <bitwise-shift-expression>
							   | <logical-relation-expression> '<=' <bitwise-shift-expression>
							   | <logical-relation-expression> '>=' <bitwise-shift-expression>

<bitwise-shift-expression> := <arithmetic-additive-expression>
							| <bitwise-shift-expression> '<<' <arithmetic-additive-expression>
							| <bitwise-shift-expression> '>>' <arithmetic-additive-expression>

<arithmetic-additive-expression> := <arithmetic-multiplicative-expression>
								  | <arithmetic-additive-expression> * <typecast-expression>
								  | <arithmetic-additive-expression> / <typecast-expression>
								  | <arithmetic-additive-expression> % <typecast-expression>

<typecast-expression> :=  <unary-expression>
						| 'typecast' <typecast-expression> '=' <type-specifier>

<unary-expression> := <postfix-expression>
					| <unary-operator> <typecast-expression>
					| 'sizeof' '(' <unary-expression> ')'
					| 'sizeof' '(' <type-specifier> ')'

<postfix-expression> := <primary-expression>
					  | <postfix-expression> '[' <expression> ']'
					  | <postfix-expression> '(' (<assignment-expression>)* ')'
					  | <postfix-expression> '.' <identifier>

<primary-expression> := <identifier>
					  | <literal>
					  | '(' <expression> ')'

<literal> :=  <numeric-literal>
			| <string-literal>
			| <enum-literal>
			

