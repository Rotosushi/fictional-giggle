

<term> := <variable-name>
		| '\\' <variable-name> ':' <type> '|' <term>
		| <term> <term>
		| <variable-name> ':=' <term>
		
<value> := nil
		 | '\\' <variable-name> ':' <type> '|' <term>
		 
<type> := Nil
		| <type> '->' <type>
		
E = environment a.k.a binding context a.k.a symbol table
dom(E) or domain(E) is the list of bound names in the environment
Typing Rules:
	the type of nil is Nil
	
		E |- nil : Nil
	
	the type of a variable is bound in the environment
	
		<variable-name> : <type> in dom(E)
		---------------------------------
		E |- <variable-name> : <type>
	
	the type of a procedure is the type of it's arg 
	-> the type of it's return term.
	 
		E, <var1> : <type1> |- <term2> : <type2>
		-----------------------------------------------------
		E |- \ <var1> : <type1> | <term2> : <type1> -> <type2>
	 
	the type of a procedure call is the return type 
	of the applied procedure
	
		E |- <term1> : <type1> -> <type2>, <term2> : <type1>
		----------------------------------------------------
		E |- <term1> <term2> : <type2>
	
	the type of a binding statement is the type of
	the term being bound.
	
		<variable-name> not in dom(E), <term2> : <type2>
		----------------------------------------------------
		E |- <variable-name> := <term2> : <type2>
	
Evaluation Rules:
	A variable can be replaced with it's value
		
		 <variable-name> : <type1> = <value1>
		------------------------------------------
			<variable-name> -> <value1>
	
	the name nil represents the value nil
	
	to evaluate procedure application
	first, fully evaluate the first term down to
	a procedure value
	second, fully evaluate the second term down to
	it's value
	third, substitute the value of the second term
	within the procedure of the first term.
	(or make the function call)
	
		<term1> -> <term1'>
		--------------------------
		<term1> <term2> -> <term1'> <term2>
		
		<term2> -> <term2'>
		---------------------------
		<value1> <term2> -> <value1> <term2'>
		
	(\ <var1> : <type1> | <term1>) (<value2) -> [<var1> -> <value2]<term1>
		
	question:
		how does our ability to bind a functions arguments one at a time
		syntactically interact with the assembly which actually calls
		functions? we cannot peicewise 'call' a function, especially in
		the case of an external function name. for which we are assuming
		having access to the typesignature will be enough to generate
		the calling semantics. i.e. the compiler and the user should
		both only need the type signature to call functions. maybe we
		allow args to be bound peicewise, but the call will get made
		the first time we have a dependancy on the resulting type/value
		of the function. then to generate the call, we recall what each 
		of the args is bound to within the current caller context and 
		generate the calling sequence with each of the args binding
		sequences required to fully complete before the call site can
		be considered semantically valid. so we could say something like,
		bind the first arg to some value, evaluate a conditional to
		bind the second arg to x or alternatively y, then make the call.
		
		f := \ x : X, y : Y | {somebody}
		
		g := \ a : A, b : B, c : C | {
			e;
			d := f a;
			if (d = <someval>) then
				e := d b
				# if we requested the final value of the function within
				# this scope should it introduce a dependancy on the
				# else scope to also request the final value of the
				# function? do we also allow the user to call the
				# function again outside the scope with the same bindings?
			else
				e := d c
			end;
			return e # call is generated here with x = a, and y = b or y = c
					 # as the return statement works over values not terms.
					 # just the letter e would also be semantically valid
					 # if we adopt the rule that the last statement in the
					 # body of a function is implicitly a return value.
		}
		
		of course the types would have to work out to be valid,
		but that is orthoginal to the current question.
		
		
		
		what about functions-as-values? 
		
		f := \ x : X |
				\ y : Y |
					x y
					
		g := \ a : A, b : B |
			e;
			d := f a;
			if (d == <someval>) then
				e := d b
			else
				e := d a
			end;
			e
		
		does this mean something substantively different than above?
		
		
	to evaluate a binding, first fully evaluate the
	right hand side term down to a value,
	second, bind the value and it's type to the left
	hand side name and insert the binding into the
	local context

	<term2> -> <term2'>
	-----------------------
	<var1> := <term2> -> <var1> := <term2'>
	
	<var1> := <value2> -> bind (E, <var1>, <type2>, <value2>)
	

