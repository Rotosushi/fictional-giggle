<program> := (<top-level-declaration>)* EOF
<top-level-declaration>  := <type-definition>
						  | <declaration>

<type-definition>     := 'alias' <identifier> '::' <type-specifier> ';'
					  | ('struct' | 'union') (<identifier>)? '::' <composite-type-block>
					  | TODO: 'enum' (<identifier>) ? '::' <enumeration-block>
					  | 'fn' <identifier> '::' <lambda-definition>

<declaration>  := <identifier> ':' <type-specifier> ';'
				| <identifier> ':' <type-specifier> '=' <initializer> ';'
				| <identifier> '::' <initializer> ';'
				| <identifier> ':=' <initializer> ';'

<initializer>  := <lambda-definition>
				| <literal>
				| <identifier>
				| <expression>

<type-specifier>   := <lambda-header>
					| <type-primitive>
					| <identifier>

<lambda-definition> := <lambda-header> <lambda-body> 

<lambda-header> := <argument-list> '->' (<return-list>)?
<lambda-body> := <block>
<block> := '{' (<declaration> | <statement>)* '}'

<composite-type-block> := '{' (<declaration>)* '}'

<argument-list> := '(' (<arg> (',' <arg>)*)? ')'

<arg> := <identifier> (':' <type-specifier>)?

<return-list> :=  '(' <type-specifier> (',' <type-specifier>)*')'

<statement> := <expression>
			 | <conditional>
			 | <iteration>
			 | <block>

<expression> := (<expr>)? ';'

<expr> := <assignment-expr>
		| <expr> ',' <assignment-expr>

<assignment-epxr>  := <ternary-expr>
					| <unary-expr> <assignment-operator> <assignment-expr>

<ternary-expr> := <logical-equality-expr>
				| <logical-equality-expr> '?' <ternary-expr> ':' <ternary-expr>

<logical-equality-expr> := <logical-relation-expr>
						 | <logical-equality-expr> '==' <logical-relation-expr>
						 | <logical-equality-expr> '!!=' <logical-relation-expr>

<logical-relation-expr> := <logical-or-expr>
						 | <logical-relation-expr> '<<' <logical-or-expr>
						 | <logical-relation-expr> '>>' <logical-or-expr>
						 | <logical-relation-expr> '<<=' <logical-or-expr>
						 | <logical-relation-expr> '>>=' <logical-or-expr>

<logical-or-expr := <logical-xor-expr>
				  | <logical-or-expr> '||' <logical-xor-expr>

<logical-xor-expr> := <logical-and-expr>
					| <logical-xor-expr> '^^' <logical-and-expr>

<logical-and-expr> := <logical-not-expr>
					| <logical-and-expr> '&&' <logical-not-expr>

<logical-not-expr> := <bitwise-or-expr>
					| '!!' <logical-not-expr>

<bitwise-or-expr>  := <bitwise-xor-expr>
					| <bitwise-or-expr> '|' <bitwise-xor-expr>

<bitwise-xor-expr> := <bitwise-and-expr>
					| <bitwise-xor-expr> '^' <bitwise-end-expr>

<bitwise-and-expr> := <bitwise-not-expr>
					| <bitwise-and-expr> '&' <bitwise-not-expr>

<bitwise-not-expr> := <bitwise-shift-expr>
					| '!' <bitwise-not-expr>

<bitwise-shift-expr> := <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '<' <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '>' <arithmetic-additive-expr>

<arithmetic-additive-expr> := <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '+' <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '-' <arithmetic-multiplicative-expr>

<arithmetic-multiplicative-expr> := <typecast-expr>
								  | <arithmetic-multiplicative-expr> '*' <typecast-expr>
								  | <arithmetic-multiplicative-expr> '/' <typecast-expr>
								  | <arithmetic-multiplicative-expr> '%' <typecast-expr>

<typecast-expr> := <unary-expr>
				 | 'typecast' <typecast-expr> '::' <type-specifier>

<unary-expr>   := <postfix-expr>
				| <unary-operator> <typecast-expr>
				| 'sizeof' ( <unary-expr> | <type-specifier> )

<postfix-expr> := <primary-expr>
				| <postfix-expr> '[' <expression> ']'
				| <postfix-expr> <argument-list>
				| <postfix-expr> '.' <identifier>

<primary-expr> := <identifier>
				| <literal>
				| '(' (<expr>)? ')'

<literal>  := <numeric-literal>
			| <string-literal>
			| <enum-literal>

<conditional>  := 'if' '(' (<expr>)? ')' <statement> 
				| 'if' '(' (<expr>)? ')' <statement> 'else' <statement>
		// TODO:| 'switch' '(' (<expr>)? ')' <switch-block>

<iteration> := 'while' '(' (<expr>)? ')' <statement>
			 | 'do' <statement> 'while' '(' (<expr>)? ')'
	// TODO: | 'for' <identifier> 'in' <iterable> <statement>

// Constants in the grammar:
<assignment-operator> :=  '='
						| '*='
						| '/='
						| '%='
						| '+='
						| '-='
						| '<='
						| '>='
						| '&='
						| '^='
						| '|='

<unary-operator> := '&'
				  | '*'
				  | '+'
				  | '-'

<type-primitive>   := 'maybe'
					| 'none'
					| 'u8'
					| 'u16'
					| 'u32'
					| 'u64'
					| 's8'
					| 's16'
					| 's32'
					| 's64'
					| 'f32'
					| 'f64'
					| 'int'
					| 'float'
					| 'char'
					| 'string'
					| 'bool'
					| '[' (<constant-expression>)? ']' // array type
					| '*'	  // pointer type

<identifier> := [a-zA-Z]([(- | _)a-zA-Z0-9])*

<numeric-literal>  := <numeric-literal-decimal>
					| <numeric-literal-hexidecimal>
					| <numeric-literal-octal>
					| <numeric-literal-binary>

<numeric-literal-decimal>	  := [0-9']*(.)?[0-9']+
<numeric-literal-hexidecimal> := ('0h' | '0H')[0-9a-fA-F']+
<numeric-literal-octal>		  := ('0o' | '0O')[0-7']+
<numeric-literal-binary>	  := ('0b' | '0B')[0-1']+