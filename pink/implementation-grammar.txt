
# variables of primitive type
# functions taking arguments, returning a list of values
# input/output via c++ stdlib

# set of possible attributes, given
# as a list of the form
# <id> ':' <type>
# I denotes the set of inherited attributes
# S denotes the set of synthesized attributes

#{
	<symbol>
	-> declares a new grapheme.
	   a grapheme can be either terminal
	   or non-terminal. terminal symbols
	   are the primitive tokens and literals
	   which compose the language. each 
	   grapheme gets state associated with it,
	   as well as a series of rules that get executed
	   before returning to the parent node.
	   
	'literal token'
	-> declares a new literal token that must
	   be matched. this declares a new terminal
	   symbol in the grammar.

	<symbol> := <symbol1> <symbol2>
	-> declares a new production.
	   each production exists in it's own environment, much
	   like functions. the lhs symbol declares a new non-terminal
	   grapheme. the symbols that appear on the rhs can be 
	   terminal or non-terminal, additionally the symbols must match
	   exactly in the order in which they appear.
	   (i don't think we can allow the lhs name
	   to appear in the first position after the EQ? I think that symbol
	   must be terminal or a literal for the grammar to be LL(1).)

	<root> := ...
	-> every valid grammar, or grammar extension has some root non-terminal 
	   grapheme. the root symbol may never appear on the rhs of any rule. the
	   root symbol of the grammar is the computational entry point.

	<non-terminal-symbol> := 'terminal-symbol' <non-terminal-symbol> <terminal-symbol>
	-> terminal symbols are symbols who are literals themselves (or something that
	   describes some literal text formatting, maybe regular expressions?)
	   non-terminals are symbols who are composed of terminal and
	   non-terminal symbols.


	<symbol> := ?()
	-> a term surrounded by ?() is optional,
	   the storage that facilitates it is not
	   however.

	<symbol> := *()
	-> a term surrounded by *() is an optional
	   list of values, that can be iterated over.

	<symbol> := +()
	-> a term surrounded by +() must match at least
	   once, and can match any number of times after.
	   it also can be iterated over.


	<symbol> := <production-1> | <production-2> | ... | <production-n>
	-> a term can be defined as a series of productions
	   each separated by |



	fn func-name (argument-list) -> return list {
		body
	}
	-> functions can be defined, and called in
	   the attributes segments. Djikstra's
	   Three will be available, in some form
	   or another. (idk if imperitive or
	   declaritive is the way to go in the
	   long run. but i know imperitive style
	   so ill be using that as my starting point.)
	    


#}


I = { position : int;
	  declarations : map(string, declaration)}
S = {	id : string;
		ids : list(string);

		int_value : int;
		real_value : float;
		text_value : string;
		bool_value : bool;
		value : (int_value | real_value | text_value | bool_value);
		type : ( INT | REAL | TEXT | BOOL | INFER );

		op : string;
		lhs : expr;
		rhs : expr;
		binop-expr : (lhs, op, rhs);
		unop-expr : (op, rhs);
		postop-expr : argument-list;
		var : ((id, type, expr) | (id, type, list(postop-expr)));
		expr : (binop-expr | unop-expr | var);

		declaration : (var, assignop, expr);
		symbol_table : map(string, declaration);

		arg : (id, type);
		argument-list : list(arg);
		return-list : list(arg);
		scope : (list(declaration), list(statement));
		function : (id, argument-list, return-list, scope);
		function-table : map(string, fn);
		
		if : (expr, statement, statement);
		while : (expr, statement, statement);
		return : expr;
		statement : (if | while | return | expr);

		import-list : list(id);
		export-list : list(id);
		root : id;

		compiler-directive : (import-list | export-list | root);
		directives : (import-list, export-list, root);

		module : (directives, symbol-table, function-table);
		}

# now the programmer needs a way of assigning
# attributes to graphemes, to use these attributes
# in the rules of the language. (empty rules are allowed)

# maybe, state attributes || semantic attributes

<program> := *(<module-declaration>) EOF { module ||
	for (it in %1) declare(%%, it);
	IR  <- generate-IR (%%);
	type_check(IR);
	asm <- convert_to_assembly(IR); 
	exe <- assemble(asm); 
	write_executable(exe, output);
}

<module-declaration> { compiler-directive | declaration |  function }
					 := <comment> {}
					  | <compiler-directive>   { %% <- %1; }
					  | <function-declaration> { %% <- %1; }
					  | <variable-declaration> { %% <- %1; }

<comment> := '#' *(_) <EOL>
# a haskell like '_'; meaning 'anything'

<compiler-directive> { compiler-directive }  
				   :=   'root' <identifier-list> ';'   { %% <- %2; }
					| 'import' <identifier-list> ';'   { %% <- %2; }
					| 'export' <identifier-list> ';'   { %% <- %2; }

# macro from observation
# <*-list> := <*> *(',' <*>) { %% <- create list(*); append(%%, %1); for (it in *) append(%%, it); }

<identifier-list> { ids } 
				:= <identifier> *(',' <identifier>) {
						append(%%, %0); 
						for (it in *) append(%%, it); 
				}

<function-declaration> { function } 
					:= 'fn' <identifier> <function-type> <function-body> {
						%% <- function(%2, %3, %4);
					}
						  

<function-type> { (argument-list, return-list) } := <arg-list> '->' ?(<type-list>) { %% <- (%1, %3); }
					

<arg-list> {argument-list} 
		:= '(' <arg> *(',' <arg>) ')' {
			append(%%, %2);
			for (it in %3) append (%%, it);
			}

<type-list> {return-list}  := '(' <type> *(',' <type>) ')'

<arg> := <identifier> ':' <type> { %% <- (%1, %2); }

<function-body> := <scope> { %% <- %1; }

<scope> := '{' *(<variable-declaration> | <statement>) '}' { %% <- scope(%2); }

<variable-declaration> { declaration } 
						:= <identifier> ':' <type> ?('=' <initializer>) ';' {
							%% <- if (%4) then declaration(%1, ':=', %3, %4)
										  else declaration($1, $2, %3);
							} 
						 | <identifier> ('::' | ':=') <initializer> ';' {
							%% = declaration (%1, %2, %3);
							}

#{
 someone may ask, hey, how exactly do the +(), *(), and ?() 
 symbols work?

 and that is a fantastic question.
 
 all parenthesis declare a new grapheme in the production they appear.
 that is to say, they are refrenced positionally as a single unit.
 and can then be syntactically and/or semantically unpacked.
 

 +() and *() both act as a list of all the
  successfull matches

  ?() acts as an option type essentially.
  either the type exists, or the entire
  expression is NONE. (or nil, or...)
#}

<type> {type}  := 'int'  { %% <- INT; } 
				| 'real' { %% <- REAL; } 
				| 'text' { %% <- TEXT; } 
				| 'bool' { %% <- BOOL; } 

<initializer> { expr } := <expression> { %% <- %1; }

<statement> { statement } 
			:= <if>			{ %% <- %1; }
			 | <while>		{ %% <- %1; }
			 | <return>		{ %% <- %1; }
			 | <scope>		{ %% <- %1; }
			 | <expression> { %% <- %1; }

<if> { if }	
	:= 'if' '(' <expression> ')' <statement> ?('else' <statement>) {
		%% <- if (%3, %5, %6);
	}
		
<while> { while } 
	:= 'while' '(' <expression> ')' <statement> {
		%% <- while (%3, %5);
	}

<return> { return } 
		:= 'return' <expression> {
			%% <- return(%2);
		}

<expression> { expr } 
		:= <expr> ';' {
			%% <- %1;
		}

# some complicated, valid expressions that should be 
# able to be parsed given this BNF grammar
# a, b, c, d = f(g + k, h - J(q), i, j);
# a = 0, b = "sometext", c = j + k, g = F() - G(P);
# 

<expr> := <parse-expression>(<primary-expr>, 0)

# this is a non-standard way of expressing this,
# this function implements the grammar of expressions in the language
# it is an instance of an operator precedence parser
<parse-expression>(lhs: _ast*, min_prec: int) := {
	lad := curtok()
	while (predict_binop(lad) & precedence(lad) >= min_prec) {
		op := lad
		nexttok()
		rhs := <primary-expr>
		lad = curtok()
		while (predict_binop(lad) & precedence(lad) > precedence(op)) {
			rhs = <parse-expression>(rhs, precedence(lad))
			lad = curtok();
		}
		lhs = create _binop(op, lhs, rhs)
	}
	return lhs
}

# my attempt at an operator-precedence parser in BNF
<parse-expression>(lhs : <ast>, min_prec: int) :=
	<primary-expr> *((<prev-binop> & precedence(<token>) >= min_prec) <primary-expr>
						*(<binop> & precedence(<token>) > precedence(<prev-binop>) <parse-expression>(<primary-expr>, precedence(<binop>)
					)

<primary-expr> := <identifier> (<call-list>)? 
				| '(' <expression> ')'
				| <unop> <primary-expr>
				| <literal>

<call-list> := '(' <expression> *(',' <expression>) ')'

# the regular way of doing operator-precedence in BNF
# (lower -> tighter binding)
<expression> := <expr> ';'

<expr> := <assignment-expr>
		| <expr> ',' <assignment-expr>

<assignment-expr> := <logical-exuality-expr>
				   | <unary-expr> <assignment-operator> <assignment-expr>

<logical-equality-expr> := <logical-relation-expr>
						 | <logical-equality-expr> '==' <logical-relation-expr>
						 | <logical-equality-expr> '!=' <logical-relation-expr>

<logical-relation-expr> := <logical-or-expr>
						 | <logical-relation-expr> '<' <logical-or-expr>
						 | <logical-relation-expr> '>' <logical-or-expr>
						 | <logical-relation-expr> '<=' <logical-or-expr>
						 | <logical-relation-expr> '>=' <logical-or-expr>

<logical-or-expr := <logical-xor-expr>
				  | <logical-or-expr> '|' <logical-xor-expr>

<logical-xor-expr> := <logical-and-expr>
					| <logical-xor-expr> '^' <logical-and-expr>

<logical-and-expr> := <logical-not-expr>
					| <logical-and-expr> '&' <bitwise-or-expr>

<bitwise-or-expr>  := <bitwise-xor-expr>
					| <bitwise-or-expr> '||' <bitwise-xor-expr>

<bitwise-xor-expr> := <bitwise-and-expr>
					| <bitwise-xor-expr> '^^' <bitwise-end-expr>

<bitwise-and-expr> := <bitwise-not-expr>
					| <bitwise-and-expr> '&&' <bitwise-shift-expr>

<bitwise-shift-expr> := <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '<<' <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '>>' <arithmetic-additive-expr>

<arithmetic-additive-expr> := <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '+' <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '-' <arithmetic-multiplicative-expr>

<arithmetic-multiplicative-expr> := <typecast-expr>
								  | <arithmetic-multiplicative-expr> '*' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '/' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '%' <postfix-expr>

<postfix-expr> := <primary-expr>
				| <postfix-expr> <argument-list>

<primary-expr> := <identifier>
				| <literal>
				| <unary-expr>
				| '(' (<expr>)? ')'
				| ')'
				| ';'

<unary-expr> := <unop> <primary-expr>

