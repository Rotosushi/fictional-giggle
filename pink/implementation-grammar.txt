
# variables of primitive type
# functions taking arguments, returning a list of values
# input/output via c++ stdlib

# set of possible attributes, given
# as a list of the form
# <id> ':' <type>
# I denotes the set of inherited attributes
# S denotes the set of synthesized attributes

#{
	<symbol>
	-> declares a new grapheme.
	   a grapheme can be either terminal
	   or non-terminal. terminal symbols
	   are the primitive tokens and literals
	   which compose the language. each 
	   grapheme gets state associated with it,
	   as well as a series of rules that get executed
	   before returning to the parent node.
	   

	<symbol> := <symbol1> <symbol2>
	-> declares a new production.
	   each production exists in it's own environment, much
	   like functions. the lhs declares a new non-terminal
	   grapheme. the symbols that appear on the rhs can be the
	   terminal or non-terminal, additionally the symbols must match
	   exactly in the order in which they appear.(i don't think we can allow the lhs name
	   to appear in the first position after the EQ? I think that symbol
	   must be terminal for the grammar to be LL(1).)

	<root> :=
	-> every valid grammar, or grammar extension has some root non-terminal 
	   grapheme. the root symbol may never appear on the rhs of any rule.

	<symbol> := 'terminal-symbol' <non-terminal-symbol>
	-> 

#}


I = { position : int;
	  declarations : map(string, declaration)}
S = {	id : string;
		ids : list(string);

		int_value : int;
		real_value : float;
		text_value : string;
		bool_value : bool;
		value : (int_value | real_value | text_value | bool_value);
		type : (INT | REAL | TEXT | BOOL);

		op : string;
		lhs : expr;
		rhs : expr;
		binop-expr : (lhs, op, rhs);
		unop-expr : (op, rhs);
		postop-expr : argument-list;
		var : ((id, type, expr) | (id, type, list(postop-expr)));
		expr : (binop-expr | unop-expr | var);

		declaration : (var, assignop, expr);
		symbol_table : map(string, declaration);

		arg : (id, type);
		argument-list : list(arg);
		return-list : list(arg);
		scope : (list(declaration), list(statement));
		fn : (id, argument-list, return-list, scope);
		functions : map(string, fn);
		
		if : (expr, statement, statement);
		while : (expr, statement, statement);
		return : expr;
		statement : (if | while | return | expr);

		import-list : list(id);
		export-list : list(id);
		root : id;

		 : (import-list | export-list | root);
		 : (import-list, export-list, root);

		module : (context-declarations, declarations, functions);
		}

# now the programmer needs a way of assigning
# attributes to graphemes, to use these attributes
# in the rules of the language. (empty rules are allowed)

# maybe, state attributes || semantic attributes
S(<program>) = { module || type_check(module); }
S(<module-declaration>) = { module }
S(<context-statement>) = { context-declaration }
S(<identifier-list>) = { ids }
S(<function-declaration>) = { fn }
S(<variable-declaration>) = { declaration }

fn define(mod : * module, dec : declaration) {
	module.declarations.add(dec);
}


<program> := *(<module-declaration>) EOF { %% = %0 }

<module-declaration> := <comment> {}
					  | <context-statement>    { declare(%%, %0); }
					  | <function-declaration> { define(%%, %0); }
					  | <variable-declaration> { define(%%, %0); }

<comment> := '#' (_)* <EOL>

<context-statement> := 'root' <identifier-list> ';' { 'root'.ids = <identifier-list>; }
					| 'import' <identifier-list> ';'   { 'import'.ids = <identifier-list>; }
					| 'export' <identifier-list> ';'   { 'export'.ids = <identifier-list>; }

# <*-list> := <*> *(',' <*>) { %% = create list(); append(%%, %1); for (it in *) append(%%, it); }

<identifier-list> := <identifier> *(',' <identifier>) { append(%%, %0); for (it in *) append(%%, it); }

<function-declaration> := 'fn' <identifier> <function-type> <function-body> 
						  { 
						    %%.id = %1.id;
						    %%.function-type = %2;
							%%.function-body = %3; 
						  }

<function-type> := <arg-list> '->' (<type-list>)? 
					{ 
						%% = (%1, %3);
					}

<arg-list> := '(' <arg> *(',' <arg>) ')' 
<type-list>   := '(' <type> *(',' <type>) ')'

<arg> := <identifier> ':' <type> { %% = (%1, %2);}

<function-body> := <scope> { %% = %1; }

<scope> := '{' *(<variable-declaration> | <statement>) '}' { %% = create _scope(*); }

<variable-declaration> := <identifier> ':' <type> ?('=' <initializer>) ';' 
						| <identifier> ('::' | ':=') <initializer> ';'

<type> := 'int'
		| 'real'
		| 'text'
		| 'bool'

<initializer> := <expression>

<statement> := <if>
			 | <while>
			 | <return>
			 | <scope>
			 | <expression>

<if>	:= 'if' '(' <expression> ')' <statement> ?('else' <statement> )
<while> := 'while' '(' <expression> ')' <statement>
<return> := 'return' <expression>

<expression> := <expr> ';'

# some complicated, valid expressions that should be 
# able to be parsed given this BNF grammar
# a, b, c, d = f(g + k, h - J(q), i, j);
# a = 0, b = "sometext", c = j + k, g = F() - G(P);
# 

<expr> := <parse-expression>(<primary-expr>, 0)

# this is a non-standard way of expressing this,
# this function implements the grammar of expressions in the language
# it is an instance of an operator precedence parser
<parse-expression>(lhs: _ast*, min_prec: int) := {
	lad := curtok()
	while (predict_binop(lad) & precedence(lad) >= min_prec) {
		op := lad
		nexttok()
		rhs := <primary-expr>
		lad = curtok()
		while (predict_binop(lad) & precedence(lad) > precedence(op)) {
			rhs = <parse-expression>(rhs, precedence(lad))
			lad = curtok();
		}
		lhs = create _binop(op, lhs, rhs)
	}
	return lhs
}

# my attempt at an operator-precedence parser in BNF
<parse-expression>(lhs : <ast>, min_prec: int) :=
	<primary-expr> *((<prev-binop> & precedence(<token>) >= min_prec) <primary-expr>
						*(<binop> & precedence(<token>) > precedence(<prev-binop>) <parse-expression>(<primary-expr>, precedence(<binop>)
					)

<primary-expr> := <identifier> (<call-list>)? 
				| '(' <expression> ')'
				| <unop> <primary-expr>
				| <literal>

<call-list> := '(' <expression> *(',' <expression>) ')'

# the regular way of doing operator-precedence in BNF
# (lower -> tighter binding)
<expression> := <expr> ';'

<expr> := <assignment-expr>
		| <expr> ',' <assignment-expr>

<assignment-expr> := <logical-exuality-expr>
				   | <unary-expr> <assignment-operator> <assignment-expr>

<logical-equality-expr> := <logical-relation-expr>
						 | <logical-equality-expr> '==' <logical-relation-expr>
						 | <logical-equality-expr> '!=' <logical-relation-expr>

<logical-relation-expr> := <logical-or-expr>
						 | <logical-relation-expr> '<' <logical-or-expr>
						 | <logical-relation-expr> '>' <logical-or-expr>
						 | <logical-relation-expr> '<=' <logical-or-expr>
						 | <logical-relation-expr> '>=' <logical-or-expr>

<logical-or-expr := <logical-xor-expr>
				  | <logical-or-expr> '|' <logical-xor-expr>

<logical-xor-expr> := <logical-and-expr>
					| <logical-xor-expr> '^' <logical-and-expr>

<logical-and-expr> := <logical-not-expr>
					| <logical-and-expr> '&' <bitwise-or-expr>

<bitwise-or-expr>  := <bitwise-xor-expr>
					| <bitwise-or-expr> '||' <bitwise-xor-expr>

<bitwise-xor-expr> := <bitwise-and-expr>
					| <bitwise-xor-expr> '^^' <bitwise-end-expr>

<bitwise-and-expr> := <bitwise-not-expr>
					| <bitwise-and-expr> '&&' <bitwise-shift-expr>

<bitwise-shift-expr> := <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '<<' <arithmetic-additive-expr>
					  | <bitwise-shift-expr> '>>' <arithmetic-additive-expr>

<arithmetic-additive-expr> := <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '+' <arithmetic-multiplicative-expr>
							| <arithmetic-additive-expr> '-' <arithmetic-multiplicative-expr>

<arithmetic-multiplicative-expr> := <typecast-expr>
								  | <arithmetic-multiplicative-expr> '*' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '/' <postfix-expr>
								  | <arithmetic-multiplicative-expr> '%' <postfix-expr>

<postfix-expr> := <primary-expr>
				| <postfix-expr> <argument-list>

<primary-expr> := <identifier>
				| <literal>
				| <unary-expr>
				| '(' (<expr>)? ')'
				| ')'
				| ';'

<unary-expr> := <unop> <primary-expr>

